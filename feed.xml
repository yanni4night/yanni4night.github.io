<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.0">Jekyll</generator><link href="https://yanni4night.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yanni4night.github.io/" rel="alternate" type="text/html" /><updated>2018-02-06T19:59:46+08:00</updated><id>https://yanni4night.github.io/</id><title type="html">人过不留名 雁过不留声</title><subtitle>越老越浓
</subtitle><entry><title type="html">isPlainObject 的不同实现</title><link href="https://yanni4night.github.io/js/2018/02/06/is-plainobject.html" rel="alternate" type="text/html" title="isPlainObject 的不同实现" /><published>2018-02-06T15:21:44+08:00</published><updated>2018-02-06T15:21:44+08:00</updated><id>https://yanni4night.github.io/js/2018/02/06/is-plainobject</id><content type="html" xml:base="https://yanni4night.github.io/js/2018/02/06/is-plainobject.html">&lt;p&gt;开头一个问题是：什么是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Plain Object&lt;/code&gt;？&lt;/p&gt;

&lt;p&gt;并没有看到有官方去专门定义它，更可能它只不过是业界的一种通俗叫法，因此也没有严格的定义。但我们在汉语环境里通常叫它“纯对象”。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;业界解释：&lt;a href=&quot;https://www.quora.com/What-is-a-plainObject-in-JavaScript&quot;&gt;https://www.quora.com/What-is-a-plainObject-in-JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们来看一下常见 Library 对 &lt;em&gt;isPlainObject&lt;/em&gt; 函数的实现。&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery&lt;/h2&gt;

&lt;p&gt;jQuery 3.3 版本中的 &lt;em&gt;isPlainObject&lt;/em&gt; 定义在&lt;a href=&quot;https://github.com/jquery/jquery/blob/3.3.0/src/core.js#L208&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;为便于阅读，核心代码经过整理后如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isPlainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// (1) null 肯定不是 Plain Object&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) 使用 Object.property.toString 排除部分宿主对象，比如 window、navigator、global&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[object Object]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getPrototypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 只有从用 {} 字面量和 new Object 构造的对象，它的原型链才是 null&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// (1) 如果 constructor 是对象的一个自有属性，则 Ctor 为 true，函数最后返回 false&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) Function.prototype.toString 无法自定义，以此来判断是同一个内置函数&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;constructor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;function&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;lodash&quot;&gt;lodash&lt;/h2&gt;

&lt;p&gt;lodash 4.0.6 版本中的 &lt;em&gt;isPlainObject&lt;/em&gt; 定义在&lt;a href=&quot;https://github.com/lodash/lodash/blob/4.0.6-npm-packages/lodash.isplainobject/index.js#L125&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;基本与 jQuery 版本相同，多了一个 &lt;em&gt;Ctor instanceof Ctor&lt;/em&gt; 的条件，满足此条件的仅有 &lt;em&gt;Function&lt;/em&gt; 和 &lt;em&gt;Object&lt;/em&gt; 两个函数。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isPlainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'[object Object]'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getPrototypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'constructor'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'function'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Ctor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;redux&quot;&gt;redux&lt;/h2&gt;

&lt;p&gt;redux 从 4.0.0 开始在测试中使用了 &lt;em&gt;isPlainObject&lt;/em&gt;，代码在&lt;a href=&quot;https://github.com/reactjs/redux/blob/v4.0.0-beta.1/src/utils/isPlainObject.js#L5&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它的实现比较简单。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isPlainObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getPrototypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getPrototypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// proto = null&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getPrototypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;proto&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;我们并没有一个能判断 &lt;em&gt;Plain Object&lt;/em&gt; 的清晰逻辑，大概能理出来的思路是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先判断 obj 本身是否满足我们熟悉的合法对象概念；&lt;/li&gt;
  &lt;li&gt;判断 obj 的构造函数是不是 Object&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至于判断 prototype 是不是 null，无非是一种 shortcut 罢了。&lt;/p&gt;</content><author><name></name></author><summary type="html">开头一个问题是：什么是 Plain Object？</summary></entry><entry><title type="html">2018 新年伊始·技术·工作</title><link href="https://yanni4night.github.io/other/2018/01/13/outlook.html" rel="alternate" type="text/html" title="2018 新年伊始·技术·工作" /><published>2018-01-13T21:23:40+08:00</published><updated>2018-01-13T21:23:40+08:00</updated><id>https://yanni4night.github.io/other/2018/01/13/outlook</id><content type="html" xml:base="https://yanni4night.github.io/other/2018/01/13/outlook.html">&lt;p&gt;已经不关注社区有大半年了，或者起码有一年了，毕竟被持续增长的业务缠了也有一年了，虽然很“充实”，但毫无疑问地说，也是一无所获。&lt;/p&gt;

&lt;p&gt;因为这一年来始终在 &lt;code class=&quot;highlighter-rouge&quot;&gt;React Naitve&lt;/code&gt; 体系上工作，传统 Web 的知识也忘得大半了。还记得去年专门写过一篇&lt;a href=&quot;http://www.infoq.com/cn/articles/2016-review-frontend&quot;&gt;文章&lt;/a&gt;来总结2016年前端社区的现状，一年过去了，如果我不是特别孤陋寡闻的话，那么，我认为，现状并没有改变多少。&lt;/p&gt;

&lt;h2 id=&quot;框架&quot;&gt;框架&lt;/h2&gt;

&lt;h3 id=&quot;react&quot;&gt;&lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;React 经历了一次许可证的“惊心动魄”，虽然新版本的许可证已经是安全的，但有一定研发实力的公司都已经在造自己的轮子。当然，从开发者的角度，肯定是使用成熟的方案更舒服，显然近在咫尺的理想也不见得能容易实现。&lt;/p&gt;

&lt;p&gt;React 16 启用了新的引擎，这些细节是值得玩味的。&lt;/p&gt;

&lt;p&gt;除此之外，React 依然拥有大量的开发者用户，就像去年一样。&lt;/p&gt;

&lt;h3 id=&quot;angular&quot;&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;未曾想到的是，Angular 2 还立足未稳，Angular 4 就出现了。刚刚看到一篇文章，作者抱怨自己的项目使用了 Angular 2 的 beta 开发之后，暂且不表 TypeScript 语法的绑定，光是要快速 follow 短时间内几十个版本的升级就已经相当心累了。&lt;/p&gt;

&lt;p&gt;当然你可以说这位开发者在一开始就不应该使用 beta 版本，但是要等到正式版本发布的话，究竟是什么时候呢？我还记得 Angular 2 的核心包去掉了 &lt;em&gt;beta&lt;/em&gt; 后缀的时候，其官方维护的一众功能包，比如动画等等，依旧是在 &lt;em&gt;alpha/beta&lt;/em&gt; 状态。好吧，即使等到所有包都达到了起码的 stable 状态，Angular 4 的出现又是几个意思呢？&lt;/p&gt;

&lt;p&gt;可以预见，Angular 1 时代的用户，相当一部分会放弃继续使用 Angular 的升级版本。曾经也一味推崇 Angular 2 的我，也渐渐失去了耐心。说到底，还是 Angular 的开发团队自己玩死的。&lt;/p&gt;

&lt;h3 id=&quot;vue&quot;&gt;&lt;a href=&quot;https://vuejs.org/v2/guide/&quot;&gt;Vue&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;其实去年的这个时候，我是比较看衰 Vue 的，语法不喜欢、个人维护难以为继，和 React、Angular 甚至 &lt;a href=&quot;https://www.emberjs.com&quot;&gt;Ember&lt;/a&gt; 完全没法比。&lt;/p&gt;

&lt;p&gt;不过 Vue.js 的流行程度经过这一年来，毫无减弱的趋势，我想至少有一下几方面原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;稳定，用户不必在业务迭代的同时，额外烦恼于持续升级基础框架；&lt;/li&gt;
  &lt;li&gt;简单，上手容易，具有普通开发经验的人，也可以在十分钟内写出一个较为复杂的应用；&lt;/li&gt;
  &lt;li&gt;生态工具较为丰富，特别是重要工具由作者维护，质量有保证且唯一，不用担心选择恐惧症&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说白了，对于真正的业务开发环境，稳定和简单是特别重要的两个特性，不求能有多激进的特性，但求省心。&lt;/p&gt;

&lt;p&gt;另外，Vue 的 ssr 方面也有足够的能力和性能支持，这在今天的 web 应用中，还是比较有吸引力的。React 生态也仅有一个简单的 &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;next.js&lt;/a&gt; 还算勉强能用，而 Angular 和 Ember 基本都属于残次品。&lt;/p&gt;

&lt;h3 id=&quot;ember&quot;&gt;Ember&lt;/h3&gt;

&lt;p&gt;Ember 属于比较小众的框架，我已经关注它有两年了，毕竟推广不多，很多人不知道，社区发展也有限。过去这一年依旧表现平平。&lt;/p&gt;

&lt;h3 id=&quot;react-native&quot;&gt;React-Native&lt;/h3&gt;

&lt;p&gt;如果说去年上半年我起码还在 &lt;code class=&quot;highlighter-rouge&quot;&gt;React Native&lt;/code&gt; 上积累了点经验的话，那么下半年基本就达到了瓶颈了。许可证是一方面，公司环境是另一方面，但这都不重要。重要的是，我依旧不看好这个东西。&lt;/p&gt;

&lt;p&gt;“行百里者半九十”，我们已经写了成千上万行代码，过亿的用户，以及良好的开发上线流程，但依旧避免不了要时刻面对框架底层缺陷带给我们的额外工作量与业务损失。作为前端开发者，过去面对浏览器兼容性起码还有前辈多年的经验积累，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;React Native&lt;/code&gt; 带给我们的就是大大提升了自身的技术钻研能力。&lt;/p&gt;

&lt;h2 id=&quot;工程化&quot;&gt;工程化&lt;/h2&gt;

&lt;h3 id=&quot;webpack&quot;&gt;&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Webpack 也从 2 升级到了3，但变化俨然远远不如从 1 到 2。使用配置难度依旧居高不下，想我这种上了年纪的人，没得商量，每次使用都要再看一遍 doc。&lt;/p&gt;

&lt;h3 id=&quot;rollup&quot;&gt;&lt;a href=&quot;https://rollupjs.org/guide/en&quot;&gt;Rollup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Rollup 的定位十分明确，与 Webpack 不构成竞争关系。写  library 用 Rollup，写 app 用 Webpack。&lt;/p&gt;

&lt;h3 id=&quot;npm&quot;&gt;npm&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://jspm.io/&quot;&gt;jspm&lt;/a&gt;、&lt;a href=&quot;https://bower.io/&quot;&gt;bower&lt;/a&gt; 几乎已成骨灰，&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; 依旧不支持 scope。&lt;/p&gt;

&lt;h2 id=&quot;新方向&quot;&gt;新方向&lt;/h2&gt;

&lt;h3 id=&quot;webassembly&quot;&gt;&lt;a href=&quot;http://webassembly.org/&quot;&gt;webassembly&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在下一代人上小学之前能看到定稿的 webassembly 我就已经满足了。&lt;/p&gt;

&lt;h3 id=&quot;webcomponents&quot;&gt;&lt;a href=&quot;https://www.webcomponents.org/&quot;&gt;webcomponents&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在下一代人上小学之前能看到普及的 webcomponents 我就已经满足了。&lt;/p&gt;

&lt;h3 id=&quot;数据&quot;&gt;数据&lt;/h3&gt;

&lt;p&gt;断断续续学习 &lt;a href=&quot;https://d3js.org&quot;&gt;D3&lt;/a&gt;，但明显精力不如从前。&lt;/p&gt;

&lt;h3 id=&quot;微信小程序&quot;&gt;微信小程序&lt;/h3&gt;

&lt;p&gt;如我所料，半温不火。令人鄙视的是，支付宝和百度都还在模仿，简直了。&lt;/p&gt;

&lt;h2 id=&quot;我的工作&quot;&gt;我的工作&lt;/h2&gt;

&lt;p&gt;去年我还在研究一种解决方案，能够兼顾的开发效率、运行时性能这两个看似简单却互为矛盾的指标。最后确实有了一个雏形。今年，我已经不再感兴趣，没有别的，就一个原因，想的太多，跟本没有那么复杂的使用场景。&lt;/p&gt;

&lt;p&gt;总体来看过去一年，对于个人来讲是毫无建树的，今年上半年，我可能需要拓展一下视野，找一找我不会做的事情做一做。&lt;/p&gt;</content><author><name></name></author><summary type="html">已经不关注社区有大半年了，或者起码有一年了，毕竟被持续增长的业务缠了也有一年了，虽然很“充实”，但毫无疑问地说，也是一无所获。</summary></entry><entry><title type="html">Unicode 如何编码成 UTF-8</title><link href="https://yanni4night.github.io/encoding/2017/11/23/utf8.html" rel="alternate" type="text/html" title="Unicode 如何编码成 UTF-8" /><published>2017-11-23T22:17:38+08:00</published><updated>2017-11-23T22:17:38+08:00</updated><id>https://yanni4night.github.io/encoding/2017/11/23/utf8</id><content type="html" xml:base="https://yanni4night.github.io/encoding/2017/11/23/utf8.html">&lt;p&gt;Unicode 是&lt;strong&gt;字符集（charset）&lt;/strong&gt;，UTF-8、UTF-16 只是 Unicode 的编码规则（encoding）。&lt;/p&gt;

&lt;p&gt;标准的 UTF-8 对 Unicode 分为4种变长的编码格式。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;区间&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;字节数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;编码格式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0~0x7F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;font color=&quot;blue&quot;&gt;0&lt;/font&gt;xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0x80~0x7FF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;font color=&quot;blue&quot;&gt;110&lt;/font&gt;xxxxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0x800~0xFFFF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;font color=&quot;blue&quot;&gt;1110&lt;/font&gt;xxxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0x10000~0x10FFFF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;font color=&quot;blue&quot;&gt;11110&lt;/font&gt;xxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx &lt;font color=&quot;blue&quot;&gt;10&lt;/font&gt;xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;也就是说，对于英文字母这种ASCII字符，UTF-8与ASCII是兼容的，都采用1字节存储。&lt;/p&gt;

&lt;p&gt;对于希伯来语字母 &lt;code class=&quot;highlighter-rouge&quot;&gt;א&lt;/code&gt;，UTF-8采用两个字节存储，方法是把它的 Unicode 码 0x05d0 的二进制形式拆成两部分，后6位前补10，再前数5位前补110，拼到一起（余下全为0），即为 0xd790。&lt;/p&gt;

&lt;pre&gt;
0x05D0 = b00000&lt;font color=&quot;red&quot;&gt;10111&lt;/font&gt;   &lt;font color=&quot;red&quot;&gt;010000&lt;/font&gt;
            110&lt;font color=&quot;red&quot;&gt;10111&lt;/font&gt; 10&lt;font color=&quot;red&quot;&gt;010000&lt;/font&gt; = 0xD790
&lt;/pre&gt;

&lt;p&gt;同样道理，汉字“我”采用3字节，Unicode 码拆成3部分：&lt;/p&gt;

&lt;pre&gt;
0x6211 = b&lt;font color=&quot;red&quot;&gt;0110   001000   010001&lt;/font&gt;
      1110&lt;font color=&quot;red&quot;&gt;0110&lt;/font&gt; 10&lt;font color=&quot;red&quot;&gt;001000&lt;/font&gt; 10&lt;font color=&quot;red&quot;&gt;010001&lt;/font&gt; = 0xE68891
&lt;/pre&gt;

&lt;p&gt;总结来看，字节起始为0则为单字节字符，起始为110、1110、11110分别代表有2个、3个、4个字节组合代表一个字符。其它字节起始必然全为10，代表不是字符起始位置。&lt;/p&gt;</content><author><name></name></author><summary type="html">Unicode 是字符集（charset），UTF-8、UTF-16 只是 Unicode 的编码规则（encoding）。</summary></entry><entry><title type="html">《咨询的奥秘》 第一章 咨询为什么这么难</title><link href="https://yanni4night.github.io/reading/2017/08/07/why-consulting-hard.html" rel="alternate" type="text/html" title="《咨询的奥秘》 第一章 咨询为什么这么难" /><published>2017-08-07T19:07:35+08:00</published><updated>2017-08-07T19:07:35+08:00</updated><id>https://yanni4night.github.io/reading/2017/08/07/why-consulting-hard</id><content type="html" xml:base="https://yanni4night.github.io/reading/2017/08/07/why-consulting-hard.html">&lt;p&gt;断断续续用了半年时间才读完了《咨询的奥秘》（今天一口气读了好几章），深感作为大牛咨询师，作者深谙计算机职场的人性，其中众多“法则”的总结无不精辟入骨，虽然鄙人不懂咨询，但从咨询的眼光和角度去看职场，不免有种“不识庐山真面目，只缘身在此山中”的彻悟。&lt;/p&gt;

&lt;p&gt;草草读过一遍甚感粗糙，因此决定第二遍细细研读。下面我努力每一章都抽出时间写下读后感。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;忽然发现，此书英文原版第一版竟出版于1986年，而内容时至今日依旧不过时。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;第一章-咨询为什么这么难&quot;&gt;第一章 咨询为什么这么难&lt;/h1&gt;

&lt;h2 id=&quot;咨询第一定律不管客户和你说什么问题总会有&quot;&gt;咨询第一定律——不管客户和你说什么，问题总会有&lt;/h2&gt;

&lt;p&gt;是的，任何系统和设计总会有或多或少的问题，可能是无足轻重的功能补充，也可能是深藏不露的致命缺陷，或大或小，但总会有。&lt;/p&gt;

&lt;p&gt;因为没有事物是完美的，所以缺陷的存在是必然的。每当有人向我滔滔不绝讲了一大堆关于他的想法，我都习惯性的点头表示“同意”，并很少打断。如果如此结束谈话，自然相安无事，我最担心的是他补上一句——“有没有什么问题？”。&lt;/p&gt;

&lt;p&gt;问题总会有，一旦我一时提不出来任何问题，我知道，我一定是没有理解他的观点，他的话被我当做了耳旁风。&lt;/p&gt;

&lt;p&gt;在面试新员工的时候，我也必然地在最后问对方有没有什么问题问我，往往我得到的答案是没有。在这个角度上，我并不喜欢没人任何问题的求职者。&lt;/p&gt;

&lt;p&gt;在会议的末尾，主持人经常询问大家有没有问题，绝大多数情况下，会议室是沉默的。&lt;/p&gt;

&lt;p&gt;显然问题的提出有助于消除歧义，增进理解，提高沟通效率；没有问题可能是不负责任、拖延症、懒惰的表现。&lt;/p&gt;

&lt;p&gt;虽然别人的问题会一直存在，但不必指出得过于强烈，要照顾自尊，因此：&lt;/p&gt;

&lt;h3 id=&quot;永远不要承诺百分之十以上的改进&quot;&gt;永远不要承诺百分之十以上的改进&lt;/h3&gt;

&lt;p&gt;这就相当于指出对方存在“很大”的问题，人非圣贤，这样指出问题无疑会招致对方强烈的反感。&lt;/p&gt;

&lt;p&gt;如果出现意外：&lt;/p&gt;

&lt;h3 id=&quot;如果不小心让改进超过百分之十要确保没人注意到它&quot;&gt;如果不小心让改进超过百分之十，要确保没人注意到它&lt;/h3&gt;

&lt;p&gt;处心积虑，为对方留足面子，处世之道。&lt;/p&gt;

&lt;h2 id=&quot;咨询第二定律不管一开始看起来什么样它永远是人的问题&quot;&gt;咨询第二定律——不管一开始看起来什么样，它永远是人的问题&lt;/h2&gt;

&lt;p&gt;诸多系统的异常在开始往往都被归咎于异常的客观事实，这种偏见非常地常见，人们在潜意识里往往不相信自己出了错。&lt;/p&gt;

&lt;p&gt;另一种理解是，无论是哪个环节出了问题，都可以归咎于人的管理失职，毕竟只有人才有主观能动性。一般来讲，人们对于难以预防的灾害，最多能够原谅一次，从第二次开始，都可以归咎于负责人对于经验总结的失察，于是：&lt;/p&gt;

&lt;h3 id=&quot;马文定律不管客户在做什么都要建议他们做些别的&quot;&gt;马文定律——不管客户在做什么，都要建议他们做些别的&lt;/h3&gt;

&lt;p&gt;抛开咨询师和客户的关系不谈，由于当局者迷，当事人往往会深陷思维定势，不妨换个角度思考，很多时候只是睡一觉、喝杯茶，问题就迎刃而解。&lt;/p&gt;

&lt;h2 id=&quot;咨询第三定律永远别忘了客户是按小时付费而不是按照解决方案付费的&quot;&gt;咨询第三定律——永远别忘了客户是按小时付费，而不是按照解决方案付费的&lt;/h2&gt;

&lt;p&gt;这一句很容易被误解，它实际上是对人性的极其深刻的讽刺——我只要向老板表态我已经在解决问题了，这是最重要的，至于最终有没有解决——原本就不可能被解决啊，否则依我的能力，早就解决了！&lt;/p&gt;

&lt;p&gt;这也导出了另一个推论：&lt;/p&gt;

&lt;h3 id=&quot;你要是在意功劳记在谁头上那就啥事也干不成了&quot;&gt;你要是在意功劳记在谁头上，那就啥事也干不成了&lt;/h3&gt;

&lt;p&gt;人们需要保留一种底线的面子，不能做出证明他一无是处的事情，谁都不想承认自己犯有严重的错误。&lt;/p&gt;

&lt;h2 id=&quot;咨询第四定律要是他们没聘用你不要帮他们解决问题&quot;&gt;咨询第四定律——要是他们没聘用你，不要帮他们解决问题&lt;/h2&gt;

&lt;p&gt;很容易理解，没主动问你，你就别瞎BB，招人烦。&lt;/p&gt;

&lt;h2 id=&quot;树莓酱定律铺的越广摊得越薄&quot;&gt;树莓酱定律——铺的越广，摊得越薄&lt;/h2&gt;

&lt;p&gt;精力有限，战线不能拉得太长，顾此失彼。这也是信息守恒的一种体现。&lt;/p&gt;

&lt;h2 id=&quot;温伯格双胞胎定律大部分时间在世界上大多数地方不管人们有多努力都不会发生什么大事&quot;&gt;温伯格双胞胎定律——大部分时间，在世界上大多数地方，不管人们有多努力，都不会发生什么大事&lt;/h2&gt;

&lt;p&gt;这印证了一句话，“努力了不一定成功，不努力一定不成功”，似乎，即使努力，成功的几率也是相当低的，很令人沮丧。但这是自然规律，熵增的趋势是极其平缓的。&lt;/p&gt;

&lt;p&gt;书中有一句话很经典：&lt;strong&gt;&lt;em&gt;对于世界上大多数系统而言，对于其下一时刻行为的最佳预测，就是和上一时刻做同样的事情&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在互联网这种信息高速传播的时代，常常会有新事物出现，往往冠以“革命性”的名头。然经过详细了解后就可以发现，大多数都只是旧瓶装新酒，仅仅对旧事物做了一定的改进，暂且不关心改进是否会带来其它的副作用，微小改进就难以称之为任何“革命”。遇到这种新事物的时候，先不要盲目追宠，相信温伯格双胞胎定律。&lt;/p&gt;

&lt;h2 id=&quot;鲁迪黄萝卜理论一旦你干掉了头号问题二号问题就升级了&quot;&gt;鲁迪黄萝卜理论——一旦你干掉了头号问题，二号问题就升级了&lt;/h2&gt;

&lt;p&gt;问题是没完没了的，队列不空，多次出栈后仍有队头。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;所以，“咨询为什么这么难”？世界上的问题是无穷无尽的，而人们又不愿意被指出自己有问题，为了照顾人家的情绪，既不能改进过多，又不能包揽全部功劳。即便如此，纵然你再努力，能够做出实质性改变的机会仍然不大。作者在最后抛出了做咨询的三条困难定律：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;要是不能接受失败，做顾问就永远不会成功&lt;/li&gt;
  &lt;li&gt;一旦消灭了头号问题，二号问题就升级了&lt;/li&gt;
  &lt;li&gt;帮助自己要比帮助别人更难&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">断断续续用了半年时间才读完了《咨询的奥秘》（今天一口气读了好几章），深感作为大牛咨询师，作者深谙计算机职场的人性，其中众多“法则”的总结无不精辟入骨，虽然鄙人不懂咨询，但从咨询的眼光和角度去看职场，不免有种“不识庐山真面目，只缘身在此山中”的彻悟。</summary></entry><entry><title type="html">理想与现实，黑与白，总结半年来React-Native的深度应用经验</title><link href="https://yanni4night.github.io/react-native/2017/07/13/react-native-reality.html" rel="alternate" type="text/html" title="理想与现实，黑与白，总结半年来React-Native的深度应用经验" /><published>2017-07-13T15:17:01+08:00</published><updated>2017-07-13T15:17:01+08:00</updated><id>https://yanni4night.github.io/react-native/2017/07/13/react-native-reality</id><content type="html" xml:base="https://yanni4night.github.io/react-native/2017/07/13/react-native-reality.html">&lt;p&gt;自从去年11月中旬在公司内部转岗后，我就一直从事着React-Native业务研发工作，算起来也有大半年了，在这项技术的应用、运维上也算是有了点经验。&lt;/p&gt;

&lt;p&gt;往往在产品上应用一项新技术的KickOff上，都必然要涉及该项技术的明显领先优势，React-Native 给人的一贯明显优势无非是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;开发效率提升&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;与Native一致的用户体验&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;无需发版，随时上线&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么如果工程做得好的话，也要必然提到它的劣势——&lt;em&gt;不够稳定&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我以前向来是个React-Native黑，我不认为它的稳定性足以支撑一项C端产品，更何况是亿级用户产品。&lt;/p&gt;

&lt;p&gt;因此，当初做React-Native算是有些被迫的，毕竟万事俱备只欠开发，毕竟要用事实说话，毕竟挣钱吃饭重要。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初期的开发工作可谓极其艰苦，不但没有开发经验，而且基础调试设施不完善，效率很低，更何况连实体测试机都不够。但最终总算是上线了。&lt;/p&gt;

&lt;p&gt;另我十分惊讶的是，不稳定性带来的客户端Crash比预想中的要低得多得多。在平台的横向比较上，Android要比iOS的奔溃率高，但还不算很离奇，勉强可以忍受。&lt;/p&gt;

&lt;p&gt;我从来不会想到这么一个残缺不堪的东西竟然真的没有掉链子，由此我反思了一下，想起了我党在40年前的那句话：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;实践是检验真理的唯一标准&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rn/reality.jpg&quot; alt=&quot;实践是检验真理的唯一标准&quot; /&gt;&lt;/p&gt;

&lt;p&gt;是的，不能因为外界的评论甚至是自己的无知，就对新事物抱有成见。除非自己亲自实践，否则无权瞎BB。&lt;/p&gt;

&lt;p&gt;经过这么一来，我对手头上的这个项目信心大增，业务的迭代速度即将迎来一次飞跃。&lt;/p&gt;

&lt;p&gt;然，下面才是冷静之后的现实，更说明了海量事实的总体分布就像那宇宙微波背景辐射一样的均匀各项同性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rn/bg.jpg&quot; alt=&quot;宇宙微波背景辐射&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;线上追踪问题困难&quot;&gt;线上追踪问题困难&lt;/h3&gt;

&lt;p&gt;React 异步渲染的性质，导致了在渲染视图中出现crash，崩溃堆栈是不会追溯到你的业务代码中的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rn/stack.png&quot; alt=&quot;crash stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这种情形下，代码被压缩根本就不是问题，问题是你完全不知道哪里出了故障，只能靠猜。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;年初我就强行猜了一次，幸运地解决了一个bug。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后如果说线上问题毕竟不在现场，不好追踪的话，那么如果同样的问题发生在了调试阶段，你能看到的只是样式错乱的页面，也不会报给你任何错误信息，就很难让人接受了。&lt;/p&gt;

&lt;p&gt;因此，【&lt;strong&gt;猜&lt;/strong&gt;】是开发React-Native的一项重要技能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rn/guess.gif&quot; alt=&quot;石头剪子布&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;android-无头问题居多&quot;&gt;Android 无头问题居多&lt;/h3&gt;

&lt;p&gt;这依然算是固有的稳定性问题。此类问题有两个特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;偶发不可复现；&lt;/li&gt;
  &lt;li&gt;逻辑上不可能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不可复现的原因很繁杂，可能与设备型号、操作系统版本、软件版本、当前运存容量、用户操作路径都有关系。还有就是一些原则上根本不可能发生的错误。&lt;/p&gt;

&lt;p&gt;这些问题由于迟迟无法解决，长时间耽误了我们全量的进程。最后属于不了了之，算是向bug妥协了。&lt;/p&gt;

&lt;h3 id=&quot;性能差&quot;&gt;性能差&lt;/h3&gt;

&lt;p&gt;相信我，KickOff 中“与Native具有相同或相近的性能”的说辞是不成立的，特别是在Android上。&lt;/p&gt;

&lt;p&gt;为了提升性能，我们不得不把能耗高的部分交给Native去实现，但这样显然又减弱了效率的优势。&lt;/p&gt;

&lt;h3 id=&quot;兼容客户端版本&quot;&gt;兼容客户端版本&lt;/h3&gt;

&lt;p&gt;如果说Web可以不考虑浏览器环境，做到始终如一的版本发布，没人会有异议，但React-Native不行。&lt;/p&gt;

&lt;p&gt;React-Native是运行在客户端上的，它的行为和格调都必须与当前客户端的环境相匹配。&lt;/p&gt;

&lt;p&gt;这意味着，一套React-Native代码必须考虑到多个客户端环境。特别是在视觉大改版的情况下，React-Native融入两套视觉代码，是什么感觉你造吗？&lt;/p&gt;

&lt;p&gt;根据版本号的if-else逻辑目前已充斥相当一部分逻辑代码中，代码越来越不够优雅。&lt;/p&gt;

&lt;h3 id=&quot;文本渲染不准确&quot;&gt;文本渲染不准确&lt;/h3&gt;

&lt;p&gt;我们已经有充分的证据证明React-Native在渲染文本特别是多行文本时存在明显的bug。这导致我们不能按照设计的预期严格的排版。&lt;/p&gt;

&lt;p&gt;此问题很深奥，而且以目前的能力来看，基本无解。&lt;/p&gt;

&lt;h3 id=&quot;坑多多&quot;&gt;坑多多&lt;/h3&gt;

&lt;p&gt;这些坑不一定是不可解决的，其实大部分我们都可以通过规避来解决，但问题是如果不进行全网搜索，你很难提前预知风险，也就严重影响了效率，往往一个奇葩的问题能耽误你一天的时间。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/super-fe/superfe-rn-troubleshooting/issues&quot;&gt;https://github.com/super-fe/superfe-rn-troubleshooting/issues&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;总结来看，应用React-Native技术带来的收益并非是特别明显的，在我看来，它最大的贡献是把一拨做业务的人悄无声息地分成了两拨，显然迭代效率就上来了。&lt;/p&gt;

&lt;p&gt;客观上，你不能无视上面提到的各种问题，但这些问题说严重就严重，说不严重也不严重，总体看来是可勉强接受的，相对于传统的客户端开发方式，依然是&lt;em&gt;各向同性的&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;从最初的腹黑到今天的淡然面对，深深感到世界系统的复杂性以及熵增的强大扭矩，革命性没那么容易，起码React-Native不是。&lt;/p&gt;</content><author><name></name></author><summary type="html">自从去年11月中旬在公司内部转岗后，我就一直从事着React-Native业务研发工作，算起来也有大半年了，在这项技术的应用、运维上也算是有了点经验。</summary></entry><entry><title type="html">2016 前端开发巡礼</title><link href="https://yanni4night.github.io/2016/12/18/2016-front-end.html" rel="alternate" type="text/html" title="2016 前端开发巡礼" /><published>2016-12-18T00:00:00+08:00</published><updated>2016-12-18T00:00:00+08:00</updated><id>https://yanni4night.github.io/2016/12/18/2016-front-end</id><content type="html" xml:base="https://yanni4night.github.io/2016/12/18/2016-front-end.html">&lt;p&gt;本文首发于 &lt;a href=&quot;http://www.infoq.com/cn/articles/2016-review-frontend&quot;&gt;http://www.infoq.com/cn/articles/2016-review-frontend&lt;/a&gt;，此处为原稿。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2016年马上过去了，像过去六年中的每一年一样，Web前端领域又产生了“面目全非”而又“耳目一新”的变化，不但旧事物持续不断地被淘汰，新事物也难保坐久江山，大有岌岌可危之势。开源界如群雄逐鹿，不断生产新的概念、新的框架、新的工具，去年中一些流行的技术今年大多得到了进一步的演进和升级，活跃度非常高，却仍然不能保证前端的未来属于它们。在今年整体资本市场冷却的大环境下，&lt;em&gt;to B&lt;/em&gt;业务的创业公司显现出了较强的生命力，这种类型的业务也给Web前端的工作带来了明显的差异性，工程师整体技能方向也展露出一丝不一样的分支。本文将从下至上、由低到高的维度盘点过去一年中Web前端领域发生的重要事件以及影响未来2017的关键性因素。视野所限，不尽完整。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一更新的网络与软件环境&quot;&gt;一、更新的网络与软件环境&lt;/h2&gt;

&lt;h3 id=&quot;11-http2-的持续普及&quot;&gt;1.1 HTTP/2 的持续普及&lt;/h3&gt;

&lt;p&gt;今年中，几乎所有的现代桌面浏览器都已经支持了HTTP/2协议，移动端依靠降级为Spdy依旧可以覆盖几乎所有平台，这样使得从协议上优化页面的性能成为了可能。&lt;/p&gt;

&lt;p&gt;同时，前端静态资源打包的必要性成为了一定程度上的争论焦点，打包合并作为传统的前端性能优化方案，它的存留对前端工程化影响极大，Facebook公司著名的静态资源动态打包方案的优越性也会被弱化。社区上多篇文章纷纷发表对HTTP/2的性能实验数据，却不仅相同。&lt;/p&gt;

&lt;p&gt;在2017年，我们相信所有大型站点都会切换HTTP/2，但依旧不会放弃对静态资源打包合并的依赖。而且。对于Server Push等高级特性，也不会有太多的应用。&lt;/p&gt;

&lt;h3 id=&quot;12-internet-explorer-8&quot;&gt;1.2 Internet Explorer 8&lt;/h3&gt;

&lt;p&gt;三年前还在考虑兼容IE6的前端技术社区，在前不久天猫宣布不再支持IE8后又引起了一股躁动。IE8是Windows XP操作系统支持的最高IE版本，放弃IE8意味着放弃了使用IE的所有XP用户。&lt;/p&gt;

&lt;p&gt;其实在2016年的今天，前端社区中框架、工具的发展早已不允许IE8的存在，angular 早在1.3版本就果断放弃了IE8，React 也在年初的v15版本上宣布放弃。在PC领域，你依旧可以使用像Backbone一样的其它框架继续对IE进行支持，但无论是从研发效率上还是从运行时效率上，放弃它都是更好的选择。&lt;/p&gt;

&lt;p&gt;由于对HTML5兼容性不佳，在2017年，相信IE9也会逐渐被社区放弃，以取得更好的性能、更少的代码体积。&lt;/p&gt;

&lt;h2 id=&quot;二如何编写javascript&quot;&gt;二、如何编写(Java)Script&lt;/h2&gt;

&lt;h3 id=&quot;21-es2016es2017babel&quot;&gt;2.1 ES2016？ES2017？babel！&lt;/h3&gt;

&lt;p&gt;去年定稿的ES2015（亦称ES6）带来了大量令人激动的新语言特性，并快速被V8和SpiderMonkey所实现。但由于浏览器版本碎片化问题，目前编写生产环境代码仍然以ES5为主。今年年中发布的ES2017带来的新特性数量少的可怜，但这正好给了浏览器厂商消化ES2015的时间，在ES2017到来之前喘口气——是的，明年的ES2017势必又会带来一大波新特性。&lt;/p&gt;

&lt;p&gt;JS解释引擎对新特性的支持程度并不能阻碍狂热的开发者使用他们，在接下来的很长时间，业界对babel的依赖必然有增无减。babel生态对下一代ECMAScript的影响会进一步加大，人们通过先增加新的babel-plugin，后向ECMA提案的方式成为了ECMAScript进化的常态。开发者编写的代码能直接运行在浏览器上的会越来越少。&lt;/p&gt;

&lt;p&gt;但使用babel导致的编译后代码体积增大的问题并没有被特别关注，由于polyfill可能被重复引入，部署到生产环境的代码带有相当一部分冗余。&lt;/p&gt;

&lt;h3 id=&quot;22-typescript&quot;&gt;2.2 TypeScript&lt;/h3&gt;

&lt;p&gt;作为ECMAScript语言的超集，TypeScript在今年取得了优异的成绩，angular 2放弃了传说中的AtScript，成为了TypeScript的最大客户。人们可以像编写Java一样编写JavaScript，有效提升了代码的表述性和类型安全性。&lt;/p&gt;

&lt;p&gt;但凡事有两面，TypeScript的特快也在不断升级，在生产环境中，你可能需要一套规范来约束开发者，防止滥用导致的不兼容，这反而增加了学习成本、应用复杂性和升级安全性。个中优劣，仍需有大量的工程实践去积累经验。&lt;/p&gt;

&lt;p&gt;此外，TypeScript也可以看做一种转译器，与babel有着类似的新特性支持。在2017年，我们期待TypeScript与babel会发展成怎样的一种微妙关系。&lt;/p&gt;

&lt;h3 id=&quot;23-promisegenerator-与-asyncawait&quot;&gt;2.3 promise、generator 与 async/await&lt;/h3&gt;

&lt;p&gt;在回调地狱问题上，近两年我们不断被新的方案乱花了眼。过去我们会利用&lt;a href=&quot;http://npm.org/async&quot;&gt;async&lt;/a&gt;来简化异步流的设计，直到“正房”Promise的到来。但它们只是callback模式的语法糖，并没有完全消除callback的使用。&lt;/p&gt;

&lt;p&gt;ES2015带来的generator/yield似乎成为了解决异步编程的一大法宝，虽然它并非为解决异步编程所设计的。但generaor的运行是十分繁琐的，因此另一个工具&lt;a href=&quot;http://npmjs.org/co&quot;&gt;co&lt;/a&gt;又成为了使用generator的必备之选。Node.js社区的koa框架初始就设计为使用generator编写洋葱皮一样的控制流。&lt;/p&gt;

&lt;p&gt;但昙花一现，转眼间async/await的语法，配合Promise编写异步代码的方式立即席卷整个前端社区，虽然async/await仍然在ES2017的草案中，但在今天，不写async/await立刻显得你的设计落后社区平均水平一大截。&lt;/p&gt;

&lt;p&gt;在Node.js上，v7已经支持在harmony参数下的async/await直接解释，在明年4月份的v8中，将会正式支持，届时，koa 2的正式版也会发布，几乎完全摒弃了generator。&lt;/p&gt;

&lt;h3 id=&quot;24-fetch&quot;&gt;2.4 fetch&lt;/h3&gt;

&lt;p&gt;受到回调问题的影响，传统的&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHttpRequest&lt;/code&gt;有被&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; API 取代之势。如今，成熟的polyfill如&lt;a href=&quot;http://npmjs.org/whatwg-fetch&quot;&gt;whatwg-fetch&lt;/a&gt;、&lt;a href=&quot;http://npmjs.org/node-fetch&quot;&gt;node-fetch&lt;/a&gt;、&lt;a href=&quot;http://npmjs.org/isomorphic-fetch&quot;&gt;isomorphic-fetch&lt;/a&gt;在npm上的每日下载量都非常大，即便对于兼容性不好的移动端，开发者也不愿使用繁琐的Ajax。借助async/await的语法，使用fetch API能让代码更简洁。&lt;/p&gt;

&lt;h2 id=&quot;三nodejs服务与工具&quot;&gt;三、node.js服务与工具&lt;/h2&gt;

&lt;h3 id=&quot;31-koa-2&quot;&gt;3.1 Koa 2&lt;/h3&gt;

&lt;p&gt;Koa与流行的Express属于“同根生”的关系，它们由同一团队打造。相比Express，新的Koa框架更轻量、更灵活。但Koa的设计在短时间内曾经出现了较大的变动，这主要受到了async/await语法对异步编程的影响。在v2版本中，koa的middleware抛弃generator转而支持async，所有第三方middleware实现，要么自行升级，要么使用&lt;a href=&quot;http://npmjs.org/koa-convert&quot;&gt;koa-convert&lt;/a&gt;进行包装转换。&lt;/p&gt;

&lt;p&gt;目前koa在node.js社区的HTTP服务端框架中受到关注度比较高，不过其在npm上latest目前仍处于1.x阶段，预计在2017年4月份发布node.js v8后，就会升级到2.x。&lt;/p&gt;

&lt;p&gt;Koa的轻量级设计意味着你需要大量第三方中间件去实现一个完整的web应用，目前鲜有看到对koa的大规模重度使用，因此也就对其无从评价。相信在明年，越来越多的产品应该会尝试部署koa 2，届时，对第三方资源的依赖冲突也会尖锐起来，这需要一个过程才能让koa的生态完备起来。预计在2018年，我们会得到一个足够健壮的koa技术栈。这会促进node.js在服务端领域的扩展，轻量级的web服务将会逐渐成为市场上的主流。&lt;/p&gt;

&lt;h2 id=&quot;四框架纷争&quot;&gt;四、框架纷争&lt;/h2&gt;

&lt;h3 id=&quot;41-jquery已死&quot;&gt;4.1 jQuery已死？&lt;/h3&gt;

&lt;p&gt;今年六月份jQuery发布了3.0版本，距离2.0发布已经有三年多的时间，但重大的更新几乎没有。由于老旧浏览器的逐渐放弃和升级，jQuery需要处理的浏览器兼容性问题越来越少，专注于API易用性和效率越来越多。&lt;/p&gt;

&lt;p&gt;随着如angular、react、ember、vue等大量具备视图数据单双向绑定能力的框架被普及，使用jQuery编写指令式的代码操作DOM的人越来越少。早在2015年便有人声称jQuery已死，社区中也进行了大量雷同的讨论，今天我们看到确实jQuery的地位已大不如前，著名的sizzle选择器在今天已完全可由&lt;em&gt;querySelector*&lt;/em&gt;原生方法替代，操作DOM也可以由框架根据数据的变动自动完成。&lt;/p&gt;

&lt;p&gt;明年jQuery在构建大型前端产品的过程中的依赖会被持续弱化，但其对浏览器特性的理解和积淀将对现有的和未来的类angular的MVVM框架的开发依旧具有很大的借鉴意义。&lt;/p&gt;

&lt;h3 id=&quot;42-angular-2&quot;&gt;4.2 angular 2&lt;/h3&gt;

&lt;p&gt;好事多磨，angular 2的正式版终于在今年下半年发布，相比于1.x，新的版本几乎是完全重新开发的框架，已经很难从设计中找到1.x的影子。陡峭的学习曲线也随之而来，npm、ES2015 Modules、decorator、TypeScript、zone.js、rxjs、JIT/AOT、e2e test，几乎都是业界这两年中的最新概念，这着实给初学者带来了不小的困难。&lt;/p&gt;

&lt;p&gt;angular 2也更面向于开发单页应用（SPA），这是对ES2015 Modules语法描述的模块进行打包（bundle）的必然结果，因此angular 2也更依赖于webpack等“bundler”工具。&lt;/p&gt;

&lt;p&gt;虽然angular 声称支持TypeScript、ECMAScript和Dart三种语言，不过显然业界对Dart没什么太大兴趣，而对于ECMAScript和TypeScript，两种语言模式下angular 2在API和构建流程上都有着隐式的（文档标注不明的）差异化，这必然会给开发者以困扰。加上业界第三方工具和组件的支持有限，TypeScript几乎是现在开发者唯一的选择。&lt;/p&gt;

&lt;p&gt;此外，angular团队已声明并没有完全放弃对1.x组件的支持，通过特有的兼容API，你可以在2.x中使用针对1.x开发的组件。鉴于不明确的风险，相信很少有团队愿意这样折腾。&lt;/p&gt;

&lt;p&gt;现在在产品中使用angular 2，在架构上，你需要考虑生产环境和开发环境下两种完全不同的构建模式，也就是JIT和AOT，这需要你有两套不一样的编译流程和配置文件。在不同环境下模块是否符合期望，可以用e2e、spec等方式来进行自动化测试，好的，那么angular 2的测试API又可能成了技术壁垒，它的复杂度可能更甚angular本身。可以确信，在业务压力的迫使下，绝大部分团队都会放弃编写测试。&lt;/p&gt;

&lt;p&gt;总之angular 2是一个非常具有竞争力的框架，其设计非常具有前瞻性，但也由于太过复杂，很多特性都会成为鸡肋，被开发者所无视。由于react*和vue的竞争，angular 2对社区的影响肯定不如其前辈1.x版本，且其更高级的特性如Server Render还没有被工程化实践，因此相信业界还会持续观望，甚至要等到下一个4.x版本的发布。&lt;/p&gt;

&lt;h3 id=&quot;43-vue-20&quot;&gt;4.3 vue 2.0&lt;/h3&gt;

&lt;p&gt;vue绝对是类MVVM框架中的一匹黑马，由作者一人打造，更可贵的是作者还是华人。vue在社区内的影响非常之大，特别是2.0的发布，社区快速生产出了无数基于vue的解决方案，这主要还是受益于其简单的接口API和友好的文档。可见作为提供商，产品的简单易用性显得尤为重要。在性能上，vue基于ES5 setter，得到了比angular 1.x脏检查机制成倍的性能提升。而2.0在模块化上又更进一步，开发难度更低，维护性更好。可以说vue准确地戳中了普通web开发者的痛点。在国内，vue与weex达成了合作，期待能给社区带来怎样的惊喜。&lt;/p&gt;

&lt;h3 id=&quot;44-react&quot;&gt;4.4 react&lt;/h3&gt;

&lt;p&gt;目前看来，react似乎仍是今年最流行的数据视图层解决方案，并且几乎已经成为了每名前端工程师的标配技能。今年react除了版本从0.14直接跃升至15，放弃了IE8以外，并没有更多爆发式的发展。人们对于使用JSX语法编写web应用已经习以为常，就像过去十年间写jQuery一样。&lt;/p&gt;

&lt;p&gt;react的代码在维护性能上显而易见，如果JSX编写得当，在重渲染性能上也具备优势，但如果只部署在浏览器环境中，那么首屏性能将会受到负面影响，毕竟在现阶段，纯前端渲染仍然快不过后端渲染，况且后端具备天生的chunked分段输出优势。我们在业界中可以看到一些负面的案例，比如某新闻应用利用react全部改写的case，就是对react的一种误用，完全不顾其场景劣势。&lt;/p&gt;

&lt;p&gt;围绕着react发展的替代品和配套工具依旧很活跃，&lt;a href=&quot;https://github.com/developit/preact&quot;&gt;preact&lt;/a&gt;以完全兼容的API和小巧的体积为卖点，&lt;a href=&quot;https://github.com/trueadm/inferno&quot;&gt;inferno&lt;/a&gt;以更快的速度为卖点，等等。每个框架都想在Virtual DOM上有所创新，但它们的提升都不是革命性的，由此而带来的第三方插件不兼容性，这种风险是开发者不愿承担的，笔者认为它们最大的意义在于能为react的内部实现提供另外的思路。就像在自然界，生物多样性是十分必要的，杂交能带来珍贵的进化优势。&lt;/p&gt;

&lt;h3 id=&quot;45-react-native&quot;&gt;4.5 react-native&lt;/h3&gt;

&lt;p&gt;今年是react-native（一下简称RN）支持双端开发的第一年，不断有团队分享了自己在RN上的实践成果，似乎前途一片大好，RN确实有效解决了传统客户端受限于发版周期、H5受限于性能的难题，做到了鱼和熊掌兼得的理想目标。&lt;/p&gt;

&lt;p&gt;但我们仍然需要质疑：首先，RN目前以两周为周期发布新版本，没有LTS，每个版本向前不兼容。也就是说，你使用0.39.0的版本编写bundle代码，想运行在0.35.0的runtime上，这几乎会100%出问题。在这种情况下，如何制定客户端上RN的升级策略？如果升级，那么业务上如何针对一个以上的runtime版本编写代码？如果不升级，那么这意味着你需要自己维护一个LTS。要知道目前每个RN的版本都会有针对前版本的bug fix，相信没有团队有精力可以在一个老版本上同步这些，如果不能，那业务端面对的将是一个始终存在bug的runtime，其开发心理压力可想而知。&lt;/p&gt;

&lt;p&gt;其次，虽然RN声称支持Android与iOS双端，但在实践中却存在了极多系统差异性，有些体现在了RN文档中，有一些则体现在了issue中，包括其它一些问题，github上RN的近700个issue足以让人望而却步。如果不能高效处理开发中遇到的各种匪夷所思的问题，那么工期就会出现严重风险。此外，RN在Android和iOS上的性能也不尽相同，Android上更差一些，即便你完成了整个业务功能，却还要在性能优化上消耗精力。并且无论如何优化，单线程模型既要实现流畅的转场动画，又要操作一系列数据，需要很高的技巧才能保证可观的性能表现。在具体的实践中，对于H5，往往由于时间关系，业务上先会上一个还算过得去的版本，过后再启动性能优化。然而对于RN，很有可能达到“过得去”的标准都需要大量的重构工作。&lt;/p&gt;

&lt;p&gt;再次，RN虽然以Native渲染元素，但毕竟是运行在JavaScript Core内核之上，依旧是单线程，相对于H5这并没有对性能有革命性质的提升。Animated动画、大ListView滚动都是老生常谈的性能瓶颈，为了解决一些复杂组件所引起的性能和兼容性问题，诸多团队纷纷发挥主动能动性，自己建设基于Native的高性能组件，这有两方面问题，一是不利于分发共享，因为它严重依赖特定的客户端环境，二是它仍依赖客户端发版，仍需要客户端的开发，违背了RN最最重要的初衷。可以想象，在大量频繁引用Native组件后，RN又退化成了H5+Hybrid模式，其UI的高性能优势将会在设备性能不断升级下被削弱，同时其无stable版本反而给开发带来了更多不可预测的风险变量。&lt;/p&gt;

&lt;p&gt;最后，RN仍然难以调试和测试，特别是依赖了特定端上组件之后，本地的自动化测试几乎成为了不可能，而绝大多数客户端根本不支持自动化测试。而调试只能利用remote debugger有限的能力，在性能分析上都十分不便。&lt;/p&gt;

&lt;p&gt;可以说RN的出现带给了移动开发以独特的新视角，使得利用JavaScript开发Native成为了可能，NativeScript、Weex等类似的解决方案也发展开来。显然RN目前最大的问题仍然是不够成熟和稳定，利用RN替代Native依然存在着诸多风险，这对于重量级的、长期维护的客户端产品可能并不是特别适合，比如Facebook自己。RN的优势显而易见，但其问题也是严重的，需要决策者对个方面利弊都有所了解，毕竟这种试错的成本不算小。&lt;/p&gt;

&lt;p&gt;由于时间关系，市场上并没有一个产品在RN的应用上有着足够久的实践经验，大部分依然属于“我们把RN部署到客户端了”的阶段，我们也无法预测这门技术的长久表现，现在评价RN的最终价值还为时尚早。在2017年，期待RN团队能做出更长足的进步，但不要太乐观，以目前的状态来看，想达到stable状态还是有着相当大的难度。&lt;/p&gt;

&lt;h3 id=&quot;46-redux-与-mobx&quot;&gt;4.6 redux 与 mobx&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt; 成功成为了 react 技术栈中的最重要成员之一。与vue一样，redux也是凭借着比其它Flux框架更简单易懂的API才能脱颖而出。不过已经很快有人开发厌烦它每写一个应用都要定义action、reducer、store以及一大堆函数式调用的繁琐做法了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;mobxjs.github.io/mobx&quot;&gt;mobx&lt;/a&gt;也是基于ES5 setter，让开发者可以不用主动调用action函数就可以触发视图刷新，它只需要一个store对象以及几个decorator就能完成配置，确实比redux简单得多。&lt;/p&gt;

&lt;p&gt;在数据到视图同步上，无论使用什么样的框架，都有一个至关重要的问题是需要开发者自己操心，那就是在众多数据变动的情形下，如何保证视图以最少的但合理的频率去刷新，以节省极其敏感的性能消耗。在redux或mobx上都会出现这个问题，而mobx尤甚。为了配合提升视图的性能，你依然需要引入action、transaction等高级概念。在控制流与视图分离的架构中，这是开发者无可避免的关注点，而对于angular、vue，框架会帮你做很多事情，开发者需要考虑的自然少了许多。&lt;/p&gt;

&lt;h3 id=&quot;47-bootstrap-4&quot;&gt;4.7 bootstrap 4&lt;/h3&gt;

&lt;p&gt;bootstrap 4处于&lt;a href=&quot;https://v4-alpha.getbootstrap.com/&quot;&gt;alpha&lt;/a&gt;阶段已经非常久了，即使现在3.x已经停止了维护，它似乎受到了twitter公司业务不景气的影响，github上的&lt;a href=&quot;https://github.com/twbs/bootstrap/issues&quot;&gt;issue&lt;/a&gt;还非常多。bootstrap是建设内部平台最佳的CSS框架，特别是对于那些对前端不甚了解的后端工程师。我们不清楚bootstrap还能坚持多久，如果twitter不得不放弃它，最好的归宿可能是把它交给第三方开源社区去维护。&lt;/p&gt;

&lt;h2 id=&quot;五工程化与架构&quot;&gt;五、工程化与架构&lt;/h2&gt;

&lt;h3 id=&quot;51-rollup-与-webpack-2&quot;&gt;5.1 rollup 与 webpack 2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://rollupjs.org/&quot;&gt;rollup&lt;/a&gt;是近一年兴起的又一打包工具，其最大卖点是可以对ES2015 Modules的模块直接打包，以及引入了Tree-Shaking算法。通过引入babel-loader，webpack一样可以对ES2015 Modules进行打包，于是rollup的亮点仅在于Tree-Shaking，这是一种能够去除冗余，减少代码体积的技术。通过分析AST（抽象语法树），rollup可以发现那些不会被使用的代码，并去除它。&lt;/p&gt;

&lt;p&gt;不过Tree-Shaking即将不是rollup的专利了，webpack 2也将支持，并也原生支持ES6 Modules。这可以说是“旁门左道”对主流派系进行贡献的一个典型案例。&lt;/p&gt;

&lt;p&gt;webpack是去年大热的打包工具，俨然已经成为了替代grunt/gulp的最新构建工具，但显然并不是这样。笔者一直认为webpack作为一个&lt;em&gt;module bundler&lt;/em&gt;，做了太多与其无关的事情，从而表象上看来这就是一个工程构建工具。经典的构建需要有任务的概念，然后控制任务的执行顺序，这正是Ant、Grunt、Gulp做的事情。webpack不是这样，它最重要的概念是&lt;em&gt;entry&lt;/em&gt;，一个或者多个，它必须是类JavaScript语言编写的磁盘文件，所有其它如CSS、HTML都是围绕着entry被处理的。估计你很难一眼从配置文件中看出webpack对当前项目进行了怎样的“构建”，不过似乎社区中并没有人提出过异议，一切都运行得很好。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;题外话：如果使用webpack构建一个没有任何JavaScript代码的工程？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新的angular 2使用webpack 2编译效果更加，不过，已经提了一年的webpack 2，至今仍处于beta阶段，好在现在已经rc，相信离release不远了。&lt;/p&gt;

&lt;h3 id=&quot;52-npmjspmbower与yarn&quot;&gt;5.2 npm、jspm、bower与yarn&lt;/h3&gt;

&lt;p&gt;在模块管理器这里，npm依旧是王者，但要说明的是，npm的全称是&lt;code class=&quot;highlighter-rouge&quot;&gt;node package mamager&lt;/code&gt;，主要用来管理运行在node上的模块，但现在却托管了大量只能运行在浏览器上的模块。造成这种现象的几个原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;webpack的大量使用，使得前端也可以并习惯于使用CommonJS类型的模块；&lt;/li&gt;
  &lt;li&gt;没有更合适的替代者，bower以前不是，以后更不会是&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前端的模块化规范过去一直处于战国纷争的年代。在node上CommonJS没什么意见。在浏览器上，虽然现在有了ES2015 Modules，却缺少了模块加载器，未来可能是&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;，但现在仍处于草案阶段。无论哪种，都仍处于JavaScript语言层面，而完整的前端模块化还要包括CSS与HTML，以及一些二进制资源。目前最贴近的方案也就只能是JSX+CSS in JS的模式了，这在webpack环境下大行其道。这种现象甚至影响了angular 2、ember 2等框架的设计。从这点看来，jspm只是一个加了层包装的壳子，完全没有任何优势。&lt;/p&gt;

&lt;p&gt;npm本身也存在着各种问题，这在实践中总会影响效率、安全以及一致性，Facebook果断地出品了yarn——npm的替代升级版，支持离线模式、严格的依赖版本管理等在工程中非常实用的特性。&lt;/p&gt;

&lt;p&gt;至于前端模块化，JavaScript有CommonJS和ES2015 Modules就够了，但工程中的组件，可能还需要在不同的框架环境中重复被开发，它们依旧不兼容。未来的话，webcomponents可能是一个比较优越的方案。&lt;/p&gt;

&lt;h3 id=&quot;53-同构&quot;&gt;5.3 同构&lt;/h3&gt;

&lt;p&gt;同构的设计在软件行业早就被提出，不过在web前端，还是在node.js、特别是react的出现后，才真正成为了可能，因为react内核的运行并不依赖于浏览器DOM环境。&lt;/p&gt;

&lt;p&gt;react的同构是一个比较低成本的方案，只要注意代码的执行环境，前后端确实可以共享很大一部分代码，随之带来的一大收益是有效克服了SPA这种前端渲染的页面在首屏性能上的瓶颈，这是所有具备视图能力的框架angular、vue、react等的共性问题，而现在，它们都在一种程度上支持server render。&lt;/p&gt;

&lt;p&gt;可以想到的做前后端同构面临的几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;静态资源如何引入，CSS in JS模式需要考虑在node.js上的兼容性；&lt;/li&gt;
  &lt;li&gt;数据接口如何fetch，在浏览器上是Ajax，在node.js上是什么；&lt;/li&gt;
  &lt;li&gt;如何做路由同构，浏览器无刷新切换页面，新路由在服务端可用；&lt;/li&gt;
  &lt;li&gt;大量DOM渲染如何避免阻塞node.js的执行进程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前github上star较多的同构框架包括vue的&lt;a href=&quot;https://github.com/nuxt/nuxt.js&quot;&gt;nuxt&lt;/a&gt;和react的&lt;a href=&quot;https://github.com/zeit/next.js&quot;&gt;next.js&lt;/a&gt;，以及数据存储全包的&lt;a href=&quot;https://www.meteor.com/&quot;&gt;meteor&lt;/a&gt;。可以肯定的是，不论它们是否能部署在生产环境中，都不可能满足你的所有需求，适当的重新架构是必要的，在这个新的领域，没有太多的经验可以借鉴。&lt;/p&gt;

&lt;h2 id=&quot;六未来技术与职业培养&quot;&gt;六、未来技术与职业培养&lt;/h2&gt;

&lt;h3 id=&quot;61-大数据方向&quot;&gt;6.1 大数据方向&lt;/h3&gt;

&lt;p&gt;越来越多做&lt;em&gt;toB&lt;/em&gt;业务的公司对前端的需求都是在数据可视化上，或者更通俗一些——报表。这个部分在从前通常都是前端工程师嗤之以鼻的方向，认为无聊、没技术。不过在移动端时代，特别是大数据时代，对此类技能的需求增多，技术的含金量也持续提升。根据“面向工资编程”的原则，一定会有大量工程师加入进来。&lt;/p&gt;

&lt;p&gt;对这个方向的技术技能要求是canvas、webgl，但其实绝大多数需求都不需要你直接与底层API打交道，已经有大量第三方工具帮你做到了，不乏非常优秀的框架。如百度的&lt;a href=&quot;http://echarts.baidu.com/&quot;&gt;echarts&lt;/a&gt;，国外的&lt;a href=&quot;http://www.chartjs.org/&quot;&gt;chart.js&lt;/a&gt;、&lt;a href=&quot;http://www.highcharts.com/&quot;&gt;highcharts&lt;/a&gt;、&lt;a href=&quot;http://d3js.org/&quot;&gt;d3.js&lt;/a&gt;等等，特别是d3.js，几乎是大数据前端方向的神器，非常值得学习。&lt;/p&gt;

&lt;p&gt;话说回来，作为工程师，心存忧患意识，一定不能以学会这几款工具就满足，在实际的业务场景中，更多的需要你扩展框架，生产自己的组件，这需要你具备一定的数学、图形和opengl底层知识，可以说是非常大的技术壁垒和入门门槛。&lt;/p&gt;

&lt;h3 id=&quot;62-webvr&quot;&gt;6.2 webVR&lt;/h3&gt;

&lt;p&gt;今年可以说是VR技术爆发式的一年，市场上推出了多款VR游戏设备，而淘宝更是开发出了平民的&lt;em&gt;buy+&lt;/em&gt;购物体验，等普及开来，几乎可以颠覆传统的网上购物方式。&lt;/p&gt;

&lt;p&gt;VR的开发离不开对3D环境的构建，webVR标准还在草案阶段，&lt;a href=&quot;https://aframe.io/&quot;&gt;A-Frame&lt;/a&gt;可以用来体验，另一个&lt;a href=&quot;https://threejs.org/&quot;&gt;three.js&lt;/a&gt;框架是一个比较成熟的构建3D场景的工具，除了能在未来的VR应用中大显身手，同样也在构建极大丰富的3D交互移动端页面中显得必不可少，淘宝就是国内这方面的先驱。&lt;/p&gt;

&lt;h3 id=&quot;63-webassembly&quot;&gt;6.3 webassembly&lt;/h3&gt;

&lt;p&gt;asm.js已发展成&lt;a href=&quot;http://webassembly.org/&quot;&gt;webassembly&lt;/a&gt;，由谷歌、微软、苹果和Mozilla四家共同推动，似乎是非常喜人乐见的事情，毕竟主要浏览器内核厂商都在这里了。不过合作的一大问题就是低效，今年终于有了可以演示的demo，允许编写C++代码来运行在浏览器上了，你需要下载一大堆依赖库，以及一次非常耗时的编译，不过好歹是个进步。&lt;/p&gt;

&lt;p&gt;短时间内，我们都不太可能改变使用JavaScript编写前端代码的现状，Dart失败了，只能期望于未来的webassembly。有了它，前端在运行时效率、安全性都会上一个台阶，其它随之而来的问题，就只能等到那一天再说了。&lt;/p&gt;

&lt;h3 id=&quot;64-webcomponents&quot;&gt;6.4 webcomponents&lt;/h3&gt;

&lt;p&gt;webcomponent能带给我们什么呢？HTML Template、Shadow DOM、Custom Element和HTML Import，是的，非常完美的组件化系统。angular、react的组件化系统中，都是以Custom Element的方式组合HTML，但这都是假象，它们最终都会被编译成JavaScript才会执行。但webcomponents不一样，Custom Element原生就可以被浏览器解析，DOM元素本身的方法都可以自定义，而且元素内部的子元素、样式，由于Shadow DOM的存在，不会污染全局空间，真正成为了一个沙箱，组件化就应该是这个样子，外部只关心接口，不关心也不能操纵内部的实现。&lt;/p&gt;

&lt;p&gt;当前的组件化，无不依赖于某一特定的框架环境，或者是angular，或者是react，想移植就需要翻盘推倒重来，也就是说他们是不兼容的。有了webcomponents，作为浏览器厂商共同遵循和支持的标准，这一现状将极有可能被改写。&lt;/p&gt;

&lt;p&gt;未来的前端组件化分发将不会是npm那么简单，可能只是引用一个html文件，更有可能的是包含CSS、HTML、JavaScript和其它二进制资源的一个目录。&lt;/p&gt;

&lt;p&gt;目前只有最新的Chrome完全支持webcomponents的所有特性，所以距离真正应用它还尚需时日。由于技术上的限制，webcomponents polyfill的能力都非常受限，Shadow DOM不可能实现，而其它三者则更多需要离线编译实现，可以参考vue 2的实现，非常类似于webcomponents。&lt;/p&gt;

&lt;h3 id=&quot;65-关于微信小程序&quot;&gt;6.5 关于微信小程序&lt;/h3&gt;

&lt;p&gt;微信小程序对于今年不得不说，却也无话可说。依托于庞大的用户量，微信官方出品了自有的一套开发技术栈，只能说给繁杂的前端开发又填了一个角色——微信前端工程师，此外，从技术上，笔者确实无语。&lt;/p&gt;

&lt;h2 id=&quot;七总结&quot;&gt;七、总结&lt;/h2&gt;

&lt;p&gt;最后还有几点需要说明。&lt;/p&gt;

&lt;h3 id=&quot;71-工程化&quot;&gt;7.1 工程化&lt;/h3&gt;

&lt;p&gt;首先，现在业界都在大谈前端工程化，人人学构建，个个会打包。鄙人认为，工程化的要点在于“平衡诸方案利弊，取各指标的加权收益最大化”。仅仅加入了项目构建是远远不够的，在实践中，我们经常需要考虑的方向大可以分为两种：一是研发效率，这直接应该响应业务需求的能力；二是运行时性能，这直接影响用户的使用体验，同时也是产品经理所关心的。这两点都直接影响了公司的收入和业绩。&lt;/p&gt;

&lt;p&gt;具体到细节的问题上来，比如说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;静态资源如果组织和打包，对于具备众多页面的产品，考虑到不断的迭代更新，如何打包能让用户的代码下载量最少（性能）？不要说使用webpack打成一个包，也不要说编译commonchunk就万事大吉了，难道还需要不断地调整编译脚本（效率）？改错了怎么办？有测试方案么？&lt;/li&gt;
  &lt;li&gt;利用angular特别是react构建纯前端渲染页面，首屏性能如何保证（性能）？引入服务端同构渲染，好的，那么服务端由谁来编写？想来必是由前端工程师来编写，那么服务端的数据层架构是怎么样的？运维角度看，前端如何保证服务的稳定（效率）？&lt;/li&gt;
  &lt;li&gt;组件化方案如何制定（效率）？如果保证组件的分发和引用的便捷性？如何保证组件在用户端的即插即用（性能）？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于工程师来说，首先需要量化每个指标的权重，然后对于备选方案，逐个计算加权值，取最大值者，这才是科学的技术选型方法论。&lt;/p&gt;

&lt;p&gt;然而在业界，很少能看到针对工程化的更深入分享和讨论，大多停留在“哪个框架好”，“使用XXX实现XXX”的阶段，往往是某一特定方向的优与劣，很少有科学的全局观。甚至只看到了某一方案的优势，对其弊端和可持续性避而不谈。造成这种现状的原因是多方面的，一是技术上，工程师能力的原因并没有考虑得到，二是政治上，工程师需要快速实现某一目标，以取得可见的KPI收益，完成团队的绩效目标，但更多的可能是，国内绝大多数产品的复杂性都还不够高，根本无需考虑长久的可持续发展和大规模的团队合作对于技术方案的影响。&lt;/p&gt;

&lt;p&gt;因此，你必须接受的现状是，无论你是否使用CSS预处理器、使用webpack还是grunt、使用react还是angular，使用RN还是Hybrid，对于产品极有可能都不是那么地敏感和重要，往往更取决于决策者的个人喜好。&lt;/p&gt;

&lt;h3 id=&quot;72-角色定位&quot;&gt;7.2 角色定位&lt;/h3&gt;

&lt;p&gt;确实，近两年，web前端工程师开始不够老实，要么用node.js插手服务端开发，要么用RN插手客户端开发。如何看待这些行为呢？&lt;/p&gt;

&lt;p&gt;鄙人以为，涉足服务端开发是没问题的，因为只涉及到渲染层面，还是属于“前端”的范畴的。况且，在实际的工程实践中，已经可以证明，优秀的前端研发体系确实离不开服务端的参与，想想Facebook的BigPipe。不过，这需要服务端良好的分层架构，数据与渲染完全解耦分离，后端工程师只负责业务数据的CRUD，并提供接口，前端工程师从接口中获取数据，并推送到浏览器上。数据解耦是比接口解耦更加优越的方案。因此现在只要你的服务端架构允许，node.js作为web服务已经比较成熟，前端负责服务端渲染是完全没有问题的。&lt;/p&gt;

&lt;p&gt;前端涉足客户端开发也是合理的，毕竟都运行在用户端，也属于前端的范畴。抛开阿里系的weex鄙人不甚了解，NativeScript、RN都还缺乏大规模持续使用的先例，这是与涉足服务端领域的不同，客户端上的方案都还不够成熟，工具的限制阻碍了前端向客户端的转型，仍然需要时间的考验。不过时间可能不会很多，未来的web技术依托高性能硬件以及普及的webgl、webrtc、Payment API等能力，在性能和功能上都会挑战Native的地位。最差的情况，还可以基于Hybrid，利用Native适当扩展能力，这就是合作而非竞争关系了。&lt;/p&gt;

&lt;p&gt;总之前端工程师的&lt;strong&gt;本&lt;/strong&gt;仍然在浏览器上，就这一点，范围就足够广使得没人有敢言自己真正“精通”前端。如果条件允许的话，特别是技术成熟之后，涉猎其它领域也是鼓励的。&lt;/p&gt;

&lt;h3 id=&quot;73-写在最后&quot;&gt;7.3 写在最后&lt;/h3&gt;

&lt;p&gt;在各种研发角色中，前端注定是一个比较心累的一个。每一年的年末，我们都能看到几乎完全不一样的世界，这背后是无数前端人烧脑思考、激情迸发的结果。无论最终产品的流行与否，都推动着前端技术领域的高速更新换代。正是印证了那一句“唯有变化为不变”。作为业务线的研发工程师，我们的职责是甄选最佳组合方案，取得公司利益最大化。这个“最佳”的涉猎面非常广，取决于设计者的技术视野广度，也有关于决策者的管理经验，从来都不是一件简单的事。&lt;/p&gt;

&lt;p&gt;未来的web前端开发体验一定是更丰富的，依托webcomponents的标准化组件体系，基于webassembly的高性能运行时代码，以及背靠HTTP/2协议的高速资源加载，前端工程师不必在性能上、兼容性上分散太多精力，从而可以专注于开发具备丰富式交互体验的下一代web APP，可能是VR，也可能是游戏。&lt;/p&gt;

&lt;p&gt;在迎接2017的同时，我们仍然要做好心理准备，新的概念、新的框架和工具以及新的语法依旧会源源不断的生产出来，不完美的现状也依旧会持续。&lt;/p&gt;

&lt;p&gt;由于水平有限，笔者在上述内容中难免有失偏颇，请多包涵。&lt;/p&gt;</content><author><name></name></author><summary type="html">本文首发于 http://www.infoq.com/cn/articles/2016-review-frontend，此处为原稿。</summary></entry><entry><title type="html">谈高质量的技术分享社区</title><link href="https://yanni4night.github.io/%E7%A4%BE%E5%8C%BA/%E6%8A%80%E6%9C%AF/2016/11/17/infoq.html" rel="alternate" type="text/html" title="谈高质量的技术分享社区" /><published>2016-11-17T10:23:40+08:00</published><updated>2016-11-17T10:23:40+08:00</updated><id>https://yanni4night.github.io/%E7%A4%BE%E5%8C%BA/%E6%8A%80%E6%9C%AF/2016/11/17/infoq</id><content type="html" xml:base="https://yanni4night.github.io/%E7%A4%BE%E5%8C%BA/%E6%8A%80%E6%9C%AF/2016/11/17/infoq.html">&lt;p&gt;由于团队架构调整，今年初夏到秋末可谓在公司无所事事，业余做了两件事：&lt;/p&gt;

&lt;h6 id=&quot;1-申请了两个公司专利&quot;&gt;1. 申请了两个公司专利&lt;/h6&gt;

&lt;p&gt;目前第一个的奖金马上到手，扣税后也就只能买两件普通价格的女人衣服。话说这年月想以专利来致富是不可能了，首先公司已经不在那个冲量的阶段了，现在对质量有些要求，你的交底书首先要经过部分专利负责人的审核，确定确实可能有一定价值，公司才会提交给专利代理撰写申请材料。据我一个在专利局相关部门的同学讲，国家对专利的审核也愈加严格了。&lt;/p&gt;

&lt;h6 id=&quot;2-向社区投了一篇文章&quot;&gt;2. 向社区投了一篇文章&lt;/h6&gt;

&lt;p&gt;为infoQ写了篇&lt;a href=&quot;http://www.infoq.com/cn/articles/constructe-tool-optimize-for-complex-web-front-end-projects&quot;&gt;首发稿件&lt;/a&gt;，基本没有读者反馈，归根到底，我认为还是里面的内容太过抽象，不当面解释，看文字是很难看懂的，即便有图例，也是很复杂的图。&lt;/p&gt;

&lt;p&gt;之所以投到infoQ，其实也属无奈，在国内，你基本找不到所谓的“高质量技术分享社区”，无论&lt;a href=&quot;http://www.csdn.net/&quot;&gt;csdn&lt;/a&gt;、&lt;a href=&quot;https://segmentfault.com/&quot;&gt;segmentfault&lt;/a&gt;，还是&lt;a href=&quot;http://gold.xitu.io/&quot;&gt;掘金&lt;/a&gt;，都充斥着大量水帖、扫盲帖和问题帖，所谓的专栏也名不副实，整个网站俨然已经成了论坛。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;国人普遍不太信任国人的文章和观点，只要你发表出来了，有三种结果，第一无人问津，原因一般是没人看得懂你在缩写什么；第二大家普遍点赞，原因一般也是看不太懂，但不觉明厉；第三是开始在评论区撕逼，读者与作者撕，读者与读者撕，基本观点是你这么做太low了，可以这样这样做等等。第三种情况是你能看到的大多数，虽然第一种最多，但你也看不见。由于担心自己的观点得不到认可，即便是最资深的从业者，也很少有人有信心在这类社区上发表自己的技术成果，明明想免费得分享，却招来一通骂，何苦呢？&lt;/p&gt;

&lt;p&gt;但想达到高质量内容的门槛，还是需要大量资深从业者的贡献。强制作者以共享版权2.0协议发布文章是不现实的，没有人愿意辛勤劳动而没有报酬。如果以购买版权或者首发权的方式付费，予以报酬，那么确实可以鼓励作者，但随之带来另一个重大问题————文章的价值无从衡量，着会导致：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;社区媒体不愿付出高昂的价格去购买无法衡量价值的文章，技术文章不同于新闻，仁者见仁、智者见智，况且抛开场景谈技术都是耍流氓，因此&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">由于团队架构调整，今年初夏到秋末可谓在公司无所事事，业余做了两件事：</summary></entry><entry><title type="html">贴吧无线 Web 的 HTTPS 改造实践</title><link href="https://yanni4night.github.io/tieba/https/2016/11/16/tieba-web-https.html" rel="alternate" type="text/html" title="贴吧无线 Web 的 HTTPS 改造实践" /><published>2016-11-16T00:00:00+08:00</published><updated>2016-11-16T00:00:00+08:00</updated><id>https://yanni4night.github.io/tieba/https/2016/11/16/tieba-web-https</id><content type="html" xml:base="https://yanni4night.github.io/tieba/https/2016/11/16/tieba-web-https.html">&lt;h2 id=&quot;1-背景&quot;&gt;1. 背景&lt;/h2&gt;

&lt;p&gt;百度公司一直都面临着严峻的安全威胁和数据隐私风险，未加密的HTTP业务流量被第三方监听、追踪甚至劫持，进而导致用户的访问页面被篡改、passport认证信息被窃取、个人数据被泄漏、下载的安装包被替换等安全问题。这些攻击产生了巨大的利益，已经成为黑色或者灰色产业成规模地运营；这些攻击不但发生在诱饵WIFI热点上，也发生在某些骨干网上；这些攻击威胁着用户的安全和隐私，也给百度的声誉和利益带来巨大损失。&lt;/p&gt;

&lt;p&gt;全站HTTPS化改造，可以有效的解决网络劫持、隐私泄漏等严重安全问题，这在百度连接人与服务，打造支付闭环的背景下，显得极其重要。在政策层面上，也对公司在安全和拥护隐私保护方面提出了更高的要求。另一方面，由于HTTP2.0在主流浏览器实现上强制要求HTTPS，这一技术变革也无法避免。&lt;/p&gt;

&lt;p&gt;贴吧是一个具有十余年历史的老产品，拥有庞大的用户群体，每日PV数十亿量级。它暴露在HTTP下的不安全性将会比其它产品线对用户的影响更严重、范围更广。为了响应公司技术委员会和安全工作组的号召，贴吧在2016年Q2启动了改造HTTPS的改造工作。&lt;/p&gt;

&lt;h2 id=&quot;2-评估&quot;&gt;2. 评估&lt;/h2&gt;

&lt;h3 id=&quot;21-范围&quot;&gt;2.1 范围&lt;/h3&gt;

&lt;p&gt;贴吧多年的业务运营，造成了前端代码十分繁杂和分散，从功能机时代的无线WAP页面，到现今的智能手机H5版本（以下简称“智能版”）、PAD版和PC版都有部署，时间跨度在5年以上，很多代码都已经找不到负责人，因此踩坑的几率极大。为了尽可能地降低对用户的影响，同时使得整个改造周期不要拉得太长，我们决定分端改造，先改造智能版。&lt;/p&gt;

&lt;h3 id=&quot;22流程&quot;&gt;2.2流程&lt;/h3&gt;

&lt;p&gt;由于智能版相对与贴吧PC版与移动客户端来说关注度不高，一开始我们采取的改造流程非常简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建设HTTPS开发环境&lt;/li&gt;
  &lt;li&gt;改造代码&lt;/li&gt;
  &lt;li&gt;QA验证&lt;/li&gt;
  &lt;li&gt;小流量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上线的流程是有致命问题的，我们后面会提到。&lt;/p&gt;

&lt;h3 id=&quot;23-细节&quot;&gt;2.3 细节&lt;/h3&gt;

&lt;p&gt;无效的HTTPS证书会导致现代浏览器主动阻塞请求，在PC上，可以通过手动放行来强行加载页面和资源，在移动端上，一些浏览器（如Safari）则不提供此功能，从而无法加载页面。如果手动安装信任证书，则过于繁琐，在测试过程中不具有实际可操作性。&lt;/p&gt;

&lt;p&gt;真实的HTTPS证书只存在于公司的线上环境中，应用于_*.baidu.com_，因此，我们申请了一台线上机器，但不接入任何用户流量。在内网环境，需要绑hosts，就可以像正常一样去访问了。&lt;/p&gt;

&lt;h2 id=&quot;3-改造&quot;&gt;3. 改造&lt;/h2&gt;

&lt;p&gt;迁移HTTPS在代码上需要改动的点主要包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;域名代理；&lt;/li&gt;
  &lt;li&gt;资源路径；&lt;/li&gt;
  &lt;li&gt;跳转页面；&lt;/li&gt;
  &lt;li&gt;动态链接；&lt;/li&gt;
  &lt;li&gt;CORS；&lt;/li&gt;
  &lt;li&gt;白名单&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;考虑到小流量模式下，HTTP与HTTPS是共存的，因此应以相对协议“&lt;strong&gt;//&lt;/strong&gt;”引用所有的静态资源和iframe，用同一套代码支持两种协议。注意在PC的IE8浏览器上，使用相对协议引用CSS会造成两次下载行为。这个bug仅影响加载性能，但贴吧的IE8浏览器用户并不多，且本次改造仅涉及无线端，因此暂不予考虑。&lt;/p&gt;

&lt;h3 id=&quot;31-域名代理&quot;&gt;3.1 域名代理&lt;/h3&gt;

&lt;p&gt;注意你可能无法将所有的资源都简单地替换为HTTPS或相对协议，因为有些域名，比如说引用的第三方资源，可能并不支持HTTPS。这种情况下，我们有两种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果是静态不变资源，将其下载，上传到我们的CDN服务器上，比如图片；&lt;/li&gt;
  &lt;li&gt;如果资源的内容可能会被改变，使用代理域名代理其地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代理是改造HTTPS过程中所必不可少的，即使是百度自己的域名，也有非常多的并没有部署HTTPS证书，因此我们对于不支持的域名，直接使用了代理域名进行了替换，这是一个已经存在的公司内部代理服务。这种域名替换可以是硬性的，即无论当前页面是处于HTTP下还是处于HTTPS下，都走HTTPS的代理域名——HTTP页面下完全允许加载HTTPS的资源；也可以是软性的，仅在HTTPS下使用代理域名。&lt;/p&gt;

&lt;p&gt;主要特别注意的是，代理可能需要&lt;strong&gt;透传&lt;/strong&gt;HTTP协议的&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1&quot;&gt;end-to-end&lt;/a&gt;头部以及所有search参数，当然也包括负载。如果有可能地话，GET、POST之外的其它method最好也能予支持。例如我们有一个地址：&lt;em&gt;http://www.test.com/a/b/c?d=1&amp;amp;e=2&lt;/em&gt;，在替换为地理地址后则可能为 &lt;em&gt;https://www.proxy.com/a/b/c?d=1&amp;amp;e=2&lt;/em&gt;，路径和参数是不变的。&lt;/p&gt;

&lt;h3 id=&quot;32-资源路径&quot;&gt;3.2 资源路径&lt;/h3&gt;

&lt;p&gt;我们在这里把资源分为静态资源和框架资源（即iframe），仅感官差异，但并无实质区别。&lt;/p&gt;

&lt;p&gt;HTTPS页面中加载的非HTTPS资源被称为&lt;strong&gt;Mixed Content&lt;/strong&gt;。理论上，Mixed Content会对HTTPS的页面造成安全威胁。不同的浏览器对Mixed Content的处理方式不尽相同。如果你使用过IE6，就一定会被一个提示“是否只查看安全传送的网页内容?”信息的确认对话框搅扰过，如果你点击了“是”的话，那么所有Mixed Content都&lt;strong&gt;不会&lt;/strong&gt;被加载，反之都会加载。后来的IE则默认允许加载Mixed Content图片，但script和css则仍需要用户确认。现代浏览器大多遵循了W3C的&lt;a href=&quot;https://www.w3.org/TR/mixed-content/&quot;&gt;Mixed Content&lt;/a&gt;规范，将Mixed Content分为Optionally-blockable和Blockable两类。&lt;/p&gt;

&lt;p&gt;前者包含危险系数较小，即使被篡改也无大碍的资源，比如SVG、图片、声音和视频。它们默认会被加载，但浏览器会在控制台打印警告信息。对于Chrome来讲，只要有一个Mixed Content资源，地址栏协议前面的绿色小锁就会变为灰色的感叹号&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/72f96cbajw1f7kbk1y7dij205500ldft.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后者包含的资源被篡改则更容易引起严重的后果，比如css、script、字体以及iframe。默认情况下它们是禁止被加载的。&lt;/p&gt;

&lt;p&gt;这两种Mixed Content的行为都可以通过&lt;a href=&quot;http://www.w3.org/TR/CSP2/&quot;&gt;CSP&lt;/a&gt;来自定义。&lt;/p&gt;

&lt;h4 id=&quot;321-静态资源&quot;&gt;3.2.1 静态资源&lt;/h4&gt;

&lt;p&gt;贴吧的静态资源托管于CDN上，主要有两个域名。显然此域名必须支持HTTPS，好在这个前置依赖已经ready，并不需要我们推动改造。&lt;/p&gt;

&lt;p&gt;在HTML页面中加载的所有css和script，都是在运行时拼接的URL。其中域名部分是从配置文件中读取的，因此只要修改该配置文件即可。但还有更多的单case外链资源的URL是硬编码到代码中的，这部分需要挨个文件搜索排查。&lt;/p&gt;

&lt;p&gt;除了css和script这两种静态资源外，无线页面上还有视频、声音和图像等媒体静态资源我们也尽可能地替换为HTTPS协议，虽然可能影响页面整体的性能，但这是值得的。&lt;/p&gt;

&lt;p&gt;如果一个js脚本加载了另一个js脚本会怎么样呢？这对于一些独立的组件（如广告）来说非常常见。你必须确保被异步加载的js也要通过HTTPS去下载。如果不能，那么你可能需要一些非技术手段去解决它。我们推动了其它部门进行了相应的改造，这里往往是整个项目的风险点，因为如果你不是对所有业务都熟悉的话，那么依赖于外部则很容易让进度被阻塞。&lt;/p&gt;

&lt;h4 id=&quot;322-iframe地址&quot;&gt;3.2.2 iframe地址&lt;/h4&gt;

&lt;p&gt;iframe的地址同css和script一样，必须保证与页面协议一致（除非配置了CSP），否则不能加载。这非常严重，因为很多跨域技术（如passport）和广告都会使用iframe，直接影响KPI指标与收入。&lt;/p&gt;

&lt;h3 id=&quot;33-跳转页面&quot;&gt;3.3 跳转页面&lt;/h3&gt;

&lt;p&gt;采用HTTPS的网站，一般都会下发&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security&quot;&gt;HSTS&lt;/a&gt;指令， 从而让浏览器直接发起HTTPS请求。对于不支持HSTS头部的浏览器，需要服务器回复一次302响应以强迫浏览器以HTTPS访问。我们希望用户能尽可能地在HTTPS协议下浏览页面，包括站内和站外的，因此，需要修改a链接的href属性。&lt;/p&gt;

&lt;p&gt;贴吧可链接至百度的其它很多产品线，但他们并非都支持HTTPS（目前百科、文库等都不支持），因此在修改外链之前一定要确保目标站点的HTTPS协议可用性。&lt;/p&gt;

&lt;h3 id=&quot;34-动态链接&quot;&gt;3.4 动态链接&lt;/h3&gt;

&lt;p&gt;其实，贴吧无线页面中的资源往往是动态部分占绝大多数，即URL是从服务端输出给前端的，无法通过硬编码的方式修改协议属性。这些URL中，有些域名是支持HTTPS的，但还有些不是。&lt;/p&gt;

&lt;p&gt;我们的解决方案是使用正则表达式去匹配并替换，为此，我们提供了三个PHP函数，以供不同场景之用：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ssl_url_replace($url){} // 替换这个URL字符串
function ssl_richtext_replace($text){} // 替换富文本中的URL
function ssl_url_replace_recursive($json){} // 递归替换数组中的URL字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在HTTP协议下访问，这三个函数均直接返回原参数；在HTTPS下访问，则会尝试匹配参数中的URL，并替换为HTTPS地址，一般是代理服务器地址（如果原域名支持HTTPS，则直接替换协议即可）。&lt;/p&gt;

&lt;p&gt;动态链接部分的改造量是所有类型工作中最大的，其代码分布非常之广，有相当一部分是由QA通过bug发现的。对于&lt;em&gt;ssl_url_replace()&lt;/em&gt;的使用，往往伴随着&lt;em&gt;&lt;img /&gt;&lt;/em&gt;标签或者&lt;em&gt;background&lt;/em&gt;以及&lt;em&gt;background-image&lt;/em&gt;内联属性。而对于其它两个函数，则很难通过搜索源代码找到其位置。&lt;/p&gt;

&lt;h3 id=&quot;35-cors&quot;&gt;3.5 CORS&lt;/h3&gt;

&lt;p&gt;即 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt;，是一种优雅的跨域通信方式，通过配置一些服务器响应头来实现。在贴吧的无线页面中，_CORS_被用于两种场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加载CDN域名上的字体文件（现代浏览器要求字体文件必须同域，除非配置CORS）；&lt;/li&gt;
  &lt;li&gt;向其它域上传图片&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果_CORS_的目标域名支持HTTPS，则增加响应头部即可，成本很低，字体文件即是这样的一个例子。但如果不支持的话，百度的代理服务器并不方便配置这样复杂的头部，因此我们不得不花费一周的时间申请了一个新域名并做了相应的配置。&lt;/p&gt;

&lt;h3 id=&quot;36-白名单&quot;&gt;3.6 白名单&lt;/h3&gt;

&lt;p&gt;即便如此，仍然有些页面是无法在HTTPS协议下运行的，包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;嵌入了第三方的不支持HTTPS的资源或iframe；&lt;/li&gt;
  &lt;li&gt;遗失源代码的页面；&lt;/li&gt;
  &lt;li&gt;暂且不想迁移的页面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是的，确实有少量的页面我们无法找到源代码，也就不能通过修改源代码来迁移到HTTPS下。至于第三方资源，贴吧目前有嵌入其它公司H5游戏的业务，目前几乎不可能推动其改造HTTPS。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然迁移HTTPS的大部分工作是替换链接，但URL出现的场景很多，特别要注意不要被依赖的第三方拖住进度。因此，前期的准备是十分必要的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-检验&quot;&gt;4. 检验&lt;/h2&gt;

&lt;p&gt;检查阶段由开发期间的QA测试以及小流量期间的数据观察构成。QA遍历所有重要业务，寻找可能的缺陷与故障。这是一项很繁杂的任务，但我们的QA以极高的测试覆盖度完成了任务，直至上线后也几乎没有发现任何致命缺陷。&lt;/p&gt;

&lt;p&gt;贴吧的几乎所有页面都接入了公司内部的性能检测平台，数据显示，虽然接入了TLS套接层，使用了大量的正则替换函数，但页面的性能几乎没有受到影响。&lt;/p&gt;

&lt;p&gt;开启1%小流量时，一切正常。不过随着小流量比例的增加，异常紧接而来，PV/UV等核心KPI指标开始大幅下滑，并有用户报告页面打不开。但是内网查看没有任何问题复现，经过服务端的一系列排查也一直没有发现任何问题。我们怀疑部分用户的设备在TLS1.0的使用上有问题，因此执行了一次线上统计：关闭所有的HTTPS小流量，在页面上检查对HTTPS连接的访问情况。&lt;/p&gt;

&lt;p&gt;为了模拟真实的地址环境，我们创建了一个贴吧域名的空图片URL，使用JavaScript脚本加载它并检测请求结果，伪代码大概是这样的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;track&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'success'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;track&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://www.abc.com/empty.gif?'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;em&gt;track()&lt;/em&gt;是统计函数。我们最终得到的是一个成功与失败的分布比例，这个数值经过计算后十分接近100%，于是我们认为用户访问HTTPS的通路没有问题。&lt;/p&gt;

&lt;p&gt;然而事实并非如此，经过较长时间的排查后，发现问题仍出在服务端，具体原因与公司的网络接入层架构有关，这里不表，但导致的后果是——大部分用户都不可能与服务端HTTPS所使用的443端口建立连接！&lt;/p&gt;

&lt;p&gt;那为什么之前我们统计到的访问HTTPS的成功率这么高呢？&lt;/p&gt;

&lt;p&gt;这个时候，我们才忽然意识到统计的方法可能有问题。这是一个特别特别小的图片，如果能访问到的话，应该是瞬间的（2G网络很比较慢，但统计数据表明我们的2G用户微乎其微），如果由于不能与服务器建立连接，那么报错的时延会非常地长，也就是&lt;em&gt;onerror&lt;/em&gt;很晚才会被调用，这个时间可能达10几秒以上，而我们统计的页面，用户一般不会停留这么久。这个现象的后果是，失败的计数很多都丢失了，成功率自然很高。&lt;/p&gt;

&lt;p&gt;为了验证这个猜测，我们修改了统计代码，不再一直等待&lt;em&gt;onerror&lt;/em&gt;被触发：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onerror&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;nx&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://www.abc.com/empty.gif?'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;track&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'success'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;track&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关键在于&lt;em&gt;setTimeout&lt;/em&gt;，它让程序最多等待一秒就发送了结果。经过这样的修改，我们再来看统计结果，就与理论值很接近了，验证了之前的猜测。虽然这种方案会误杀那种访问很慢但能访问得到的情况，但根据以往经验，这部分量级很少，并且我们的目标并非严格定量地统计它，这仅是一个短期的临时统计方案。&lt;/p&gt;

&lt;h2 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h2&gt;

&lt;p&gt;HTTPS改造实际上并没有太多的技巧可言，很大程度上都是一种“体力活”。但体力活并非“蛮干”，依然需要评估到所有可能的情况。我们得到的经验教训是：首先应对线上环境进行正确可信的检查，上一节中我们遇到的问题并非仅由一个原因造成的，有很多环节都可以发现问题并及时止损，但每一个环节我们都由于或行政或技术的原因与真相失之交臂，不能不说是遗憾。但反过来想我们确实达到了踩坑的目的，有效地防止了对PC端这一大头的影响，算是有一定的收获吧。其次，提前确认依赖外部团队业务的实现部分，因为你无法控制他们的资源与排期，容易拖慢你的进度。&lt;/p&gt;

&lt;p&gt;在未来的HTTPS持续改造中，我们的流程将是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证线上HTTPS环境，保证通道畅通&lt;/li&gt;
  &lt;li&gt;评估所有依赖，必要时发起合作，确定时间点接洽&lt;/li&gt;
  &lt;li&gt;建设HTTPS开发环境&lt;/li&gt;
  &lt;li&gt;改造代码，尽可能所有流量都走HTTPS&lt;/li&gt;
  &lt;li&gt;QA验证，全量覆盖，确保所有重要业务运行正常&lt;/li&gt;
  &lt;li&gt;小流量，可采用log函数递增方式缓慢开启流量，观察统计指标&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">1. 背景</summary></entry><entry><title type="html">再谈移动 Web 上的吸底布局</title><link href="https://yanni4night.github.io/css/2016/06/30/fixed-bottom-bar.html" rel="alternate" type="text/html" title="再谈移动 Web 上的吸底布局" /><published>2016-06-30T12:20:39+08:00</published><updated>2016-06-30T12:20:39+08:00</updated><id>https://yanni4night.github.io/css/2016/06/30/fixed-bottom-bar</id><content type="html" xml:base="https://yanni4night.github.io/css/2016/06/30/fixed-bottom-bar.html">&lt;p&gt;吸底布局也就是固定在页面底部，无论页面本身滚动到哪了。其最佳实现方式是使用 &lt;em&gt;position:fixed&lt;/em&gt;，然而对于移动端来讲坑要多得多。&lt;/p&gt;

&lt;p&gt;如果仅仅是吸顶的话，也就是对 fixed 的支持，也存在悲惨的过去，比如 Android 2.x 只有在特定的 viewport 设置下才会生效，iOS 在 8 以前要么不支持要么带有明显的漂移 bug。现在好多了，较新的版本都能很好地支持。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;但对吸底来讲还不一样，就是因为 &lt;strong&gt;软键盘是从底部弹起的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;软键盘弹起后，吸底的元素应该具有怎样的行为呢，这没有规范说明，于是 iOS 与 Android，Android 的不同版本之间，都各行其是。分歧在于，软键盘并非当前软件的一部分，如果它弹起了，页面的 &lt;em&gt;window&lt;/em&gt; 大小到底变没变呢？&lt;/p&gt;

&lt;p&gt;比较一致的是，两个平台上 &lt;em&gt;resize&lt;/em&gt; 事件都没有被触发。但在部分 Android 机型上，如果页面的内容不能填充屏幕的高度，则页面确实会缩短，即 &lt;em&gt;document.body.scrollHeight&lt;/em&gt; 会变小。其它 Android 和 iOS 则不会改变。&lt;/p&gt;

&lt;p&gt;iOS 在软键盘弹起后非常一致地都将吸底的元素留在原处，并没上浮到键盘上面，而一些 Android 则会上浮。&lt;/p&gt;

&lt;p&gt;两种策略很难说谁对谁错，iOS 可能有充足的理由不上浮：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;window 大小并没有变；&lt;/li&gt;
  &lt;li&gt;上浮可能导致内容区被遮挡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但很多人的第一印象是应该要上浮，就像部分 Android 做的那样。在 window 尺寸未变时，这反倒成了一种奇怪的行为，毕竟 fixed 不代表 &lt;em&gt;always-visible&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;如果不依赖 fixed，使用 JavaScript 动态计算的话，需要知道软键盘的高度，在 iOS 上一些客户端的内嵌 Webview 中，这是可能的，因为键盘弹起后 &lt;em&gt;window.innerHeight&lt;/em&gt; 这个值变化了，等于真正可视区域的高度。于是我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nc&quot;&gt;.bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;40px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nl&quot;&gt;transition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;.3s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clientHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.bottom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'position'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'absolute'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s1&quot;&gt;'bottom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fixed 已经被 absolute 代替，动态计算 &lt;em&gt;.bottom&lt;/em&gt; 元素相对于 body 的距离。注意当内容不足时，body 的高度要小于屏幕的高度。&lt;/p&gt;

&lt;p&gt;效果看下面的影片：&lt;/p&gt;

&lt;video src=&quot;/images/fixed/fixed.mp4&quot; controls=&quot;controls&quot; preload=&quot;preload&quot; width=&quot;360&quot; height=&quot;640&quot;&gt;&lt;/video&gt;

&lt;p&gt;不过这不但仅适用于 iOS，也仅在部分客户端上有效，Safari 是无效的。关于这种对吸顶元素的需求，应该还是避免。&lt;/p&gt;</content><author><name></name></author><summary type="html">吸底布局也就是固定在页面底部，无论页面本身滚动到哪了。其最佳实现方式是使用 position:fixed，然而对于移动端来讲坑要多得多。</summary></entry><entry><title type="html">Gitbook 插件的问题</title><link href="https://yanni4night.github.io/gitbook/plugin/2016/06/28/gitbook-plugins.html" rel="alternate" type="text/html" title="Gitbook 插件的问题" /><published>2016-06-28T16:03:03+08:00</published><updated>2016-06-28T16:03:03+08:00</updated><id>https://yanni4night.github.io/gitbook/plugin/2016/06/28/gitbook-plugins</id><content type="html" xml:base="https://yanni4night.github.io/gitbook/plugin/2016/06/28/gitbook-plugins.html">&lt;p&gt;&lt;a href=&quot;https://www.gitbook.com/&quot;&gt;Gitbook&lt;/a&gt; 是一个工具，可以将你的 Markdown 文档转换为 HTML、PDF 电子书，也是一个平台，你可以将电子书分享到上面去。不过严格来讲将 Markdown 发布为 HTML 没有任何技术含量，解析 Markdown 格式的工具不计其数。原始的 Markdown 语法非常简陋，在写书的时候，难免会用到一些图表、公式之类的，这种 Markdown 通过扩展也不在话下。&lt;/p&gt;

&lt;p&gt;```[type]
[content]
```&lt;/p&gt;

&lt;p&gt;&lt;em&gt;type&lt;/em&gt; 处是这段代码的解析类型，常用的有各种语言语法以及 &lt;em&gt;flowchat&lt;/em&gt;、&lt;em&gt;sequence&lt;/em&gt; 等扩展类型，这些扩展类型都需要引入运行时解析的js脚本。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Gitbook 通过注册插件，无需手动引入js：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// book.json&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;plugins&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;katex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;gitbook install&lt;/code&gt; 下载插件。&lt;/p&gt;

&lt;p&gt;打开浏览器再浏览页面时，gitbook 已经将插件中声明的样式和脚本都注入到了页面当中。&lt;/p&gt;

&lt;p&gt;但这有一个很大的问题，可以声明的脚本是个数组，你可以将任意数量的js注入到页面中，于是乎广大插件作者自然而然将依赖库放进去了，包括 jQuery，Raphael，Underscore 等等，你会看到：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;..plugin-a/book/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;..plugin-a/book/plugin-a.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;..plugin-b/book/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;..plugin-b/book/plugin-b.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是的，一个以上的插件将 jQuery 注入进去了，而 jQuery 是会向全局作用域暴露 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 对象的，后面的会覆盖前面的，这导致很多插件都不能工作了。&lt;/p&gt;

&lt;p&gt;目前官网还没有给出解决方案，对于不得不使用的插件，需要手动改造一番，尽量少向全局暴露对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.gitbook.com/plugin/js-sequence-diagram-full&quot;&gt;js-sequence-diagram-full&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.gitbook.com/plugin/mathjax-full&quot;&gt;mathjax-full&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.gitbook.com/plugin/mermaid-full&quot;&gt;mermaid-full &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.gitbook.com/plugin/flowchart-full&quot;&gt;flowchart-full&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Gitbook 是一个工具，可以将你的 Markdown 文档转换为 HTML、PDF 电子书，也是一个平台，你可以将电子书分享到上面去。不过严格来讲将 Markdown 发布为 HTML 没有任何技术含量，解析 Markdown 格式的工具不计其数。原始的 Markdown 语法非常简陋，在写书的时候，难免会用到一些图表、公式之类的，这种 Markdown 通过扩展也不在话下。</summary></entry></feed>
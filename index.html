<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>人过不留名 雁过不留声</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="人过不留名 雁过不留声">
<meta property="og:url" content="https://yanni4night.github.io/index.html">
<meta property="og:site_name" content="人过不留名 雁过不留声">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yanni4night">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="人过不留名 雁过不留声" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">人过不留名 雁过不留声</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yanni4night.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2023-01-14-how-sandbox-works" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/14/2023-01-14-how-sandbox-works/" class="article-date">
  <time class="dt-published" datetime="2023-01-14T03:32:48.000Z" itemprop="datePublished">2023-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/14/2023-01-14-how-sandbox-works/">沙箱是如何工作的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>从 <em>qiankun</em> 开始，沙箱（或沙盒、sandbox）已经成了几乎所有微前端框架的标配功能。但事实上其内部涉及实现的大量细节，导致每家的能力参差不齐。</p>
<p>严格来说，沙箱并没有遵循的标准，在一些细节上的实现也没有对错，具体行为还是要取决于业务的需求。</p>
<p><em>Node.js</em> 的<a href="https://nodejs.org/dist/latest-v18.x/docs/api/vm.html" target="_blank">vm 模块</a>并不能直接移植到浏览器端，一个很大的原因在于浏览器涉及的视图（包括 DOM、URL）无法被拷贝，只能共享，那么共享到什么水平就成了沙箱方案能力差别的衡量标准之一。</p>
<h2 id="二、变量隔离"><a href="#二、变量隔离" class="headerlink" title="二、变量隔离"></a>二、变量隔离</h2><p>沙箱的基础能力就是隔离上下文，让下列操作都只局限在特定的上下文内，不会干扰到外部：</p>
<ul>
<li>删除已有变量，如 <em>delete obj.a</em> 或 <em>Relect.deleteProperty(obj, ‘a’)</em> ；</li>
<li>修改已有变量<ul>
<li>修改取值，如 <em>obj.a&#x3D;1</em> 或 <em>Reflect.set(obj, ‘a’, 1)</em> 或 <em>Reflect.defineProperty(obj, ‘a’, { value: 1 })</em></li>
<li>修改描述符，如 <em>Reflect.defineProperty(obj, ‘a’, { writable: false })</em></li>
<li>修改 frozen、sealed、extensible 状态，如 <em>Object.freeze(obj.a)</em> 、 <em>Object.seal(obj.a)</em> 或 <em>Object.preventExtensions(obj.a)</em></li>
<li>修改原型链，如 <em>Object.setPrototypeOf(obj.a, null)</em></li>
</ul>
</li>
<li>创建新的变量，如 <em>obj.a&#x3D;1</em> 或 <em>Relect.defineProperty(obj, ‘a’, {value: 1})</em></li>
</ul>
<p>上面的 <strong>obj</strong> 对象即指上下文对象，在浏览器中通常是 <em>window</em> 或 <em>document</em> ，这两个全局对象。但事实上，window 下的所有属性都可以直接取到，如 <em>addEventListener</em> 、 <em>name</em> 、 <em>CSS</em> 、 <em>location</em> 、 <em>history</em> 、 <em>navigator</em> 、 <em>HTMLElement</em> 等等，不胜枚举。因此， <strong>沙箱不可能监视所有变量的属性删除&#x2F;修改&#x2F;创建，因此也就不可能实现“完美”沙箱</strong> ，毕竟你不能遍历 window 下的所有属性，都监视一遍。</p>
<p><strong>with(){}</strong> 的做法不在考虑范围之内，对性能损耗过大。</p>
<p>这个事实带来的后果是，如果你想逃逸出沙箱，是非常容易的，比如 <em>navigator.no&#x3D;1</em> 。所以，沙箱在微前端中有使用价值的前提是， <strong>你必须尽可能保障对全局变量的访问是可控、无副作用的</strong> ，这是沙箱的脆弱之处，也是一种规范。接下来我们将在这一规范下继续讨论沙箱的实现问题，假设我们只考量对 window 和 document 这两个变量的属性监视。</p>
<h3 id="2-1-属性监视"><a href="#2-1-属性监视" class="headerlink" title="2.1 属性监视"></a>2.1 属性监视</h3><p>毫无疑问，在现代浏览器中，Proxy 是监视对象的最佳方案，通过它，我们应该可以被通知且控制获取、修改、删除、遍历等几乎所有操作。但是，proxy 对象真的可以为所欲为吗？</p>
<p>观察下列代码：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/yanni4night/xms2nkpa/15/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>这里涉及到了关于 <em>configurable</em> 导致的错误，事实上，有大量的操作都是被 proxy 所禁止的，在 <em>ECMA262</em> 上的<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>部分搜索 <strong>Invariants</strong> 能查询得到。因此 proxy 对象并非无所不能，它无法任意伪装原始对象的行为， <strong>该失败的必须失败</strong> 。相关规则包括如下：</p>
<table class="table">
    <thead>
        <th>对象操作</th>
        <th>不变量</th>
    </thead>
    <tbody>
        <tr>
            <td>defineProperty</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么使用defineProperty新增属性时不能返回true；</li>
                    <li>如果目标对象没有不可配置属性a，则代理对象也不能用defineProperty在将属性a定义成不可配置时时返回true；</li>
                    <li>如果目标对象没有不可配置且不可写的属性a，则代理对象也不能用defineProperty在将不可配置属性a定义成不可写时返回true</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>deleteProperty</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>get</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象在用get取值a时必须返回和目标对象相同值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少get的存取类型，那么代理在用get取值a时必须返回undefined</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getOwnPropertyDescriptor</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且没有有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时必须返回undefined；</li>
                    <li>除非目标对象有不可配置且不可写的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时就不能是不可配置且不可写的；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getPrototypeOf</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用getPrototypeOf时必须返回与在目标对象上调用的返回值</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>has</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用has获取a时不能返回false；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用has获取a时不能返回false；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>ownKeys</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用ownKeys时必须返回目标对象的全部属性名，不能包含额外属性名</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>set</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象就不能用set给a设置不同的值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少set的存取类型，那么代理在用set设值a时必须返回false</li>
                </ol>
            </td>
        </tr>
    </tbody>
</table>

<p>看似复杂，但实际总结来看，就是代理对象必须遵循一个原则： <strong>操作的结果要真实反应 target 的最新状态。</strong></p>
<p>举几个例子：</p>
<ul>
<li>如果Reflect.has(proxyObj, ‘a’)返回true，那么target就必须不能有一个不可配置的属性a；</li>
<li>如果Reflect.set(proxyObj, ‘a’, 1)返回true，那么target对象必然不能是不可扩展的，也不可以有一个不可写也不可配置的属性a</li>
</ul>
<p>如下的做法，直接代理原始 window、document 肯定是不可以的，根据上面的 Invariants 可知我们几乎必须把属性同步给原始的 window、document 才能不报错，显然违背我们做沙箱的初衷。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="variable language_">window</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>因此，通常的做法是把一个 <strong>新创建的对象</strong> 当作原始对象进行代理，下文简称为 <strong>target</strong> 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>所有的操作几乎都是最终体现在 target 对象上的，个别稍有例外。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">defineProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey, attributes: PropertyDescriptor</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="property">defineProperty</span>)(target, p, attributes);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deleteProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getOwnPropertyDescriptor</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="title class_">PropertyDescriptor</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">has</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params">target: T</span>): <span class="title class_">ArrayLike</span>&lt;<span class="built_in">string</span> | <span class="built_in">symbol</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey, value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getPrototypeOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">window</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但显然这样是有严重问题的，因为 target 是伪装的 Window 对象，它身上没有任何属性，这不但会影响 get、getOwnPropertyDescriptor、has、ownKeys 这些只读操作的结果，由于 Proxy 的规则，同样也会影响 defineProperty、deletePrperty、set 这些写操作的结果。</p>
<p>举个例子，本来真实 window 对象上有一个不可配置的属性 foo，正常来说，我们用 defineProxy 修改其描述符类型时一定会报错，但是 target 本身并没有任何属性，Reflect.defineProperty(target)却是成功的，不符合期望。</p>
<p>于是，业界常规的做法都是会把 <strong>原始对象的自身属性拷贝到 target 中，特别是那些不可配置的属性</strong> 。这样无论是读操作还是写操作，其结果都真实反应到了代码对象的 target 中，不会被任何 Proxy 原则所影响。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="variable language_">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> descriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, key);</span><br><span class="line">  <span class="keyword">if</span> (!descriptor.<span class="property">configurable</span>) <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, p, descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步的成本稍高，但是又是必须的。在具体的实现策略上也可以区分为一次性拷贝和懒惰式拷贝，即用到某属性时才执行拷贝。</p>
<h3 id="2-2-主动变量逃逸"><a href="#2-2-主动变量逃逸" class="headerlink" title="2.2 主动变量逃逸"></a>2.2 主动变量逃逸</h3><p>虽然沙箱的关键作用就是为了限制变量的访问和变更范围，但是毕竟在同一个浏览器页面之下，难免有需要例外放行的 case。我们称这类变量为 exception 或者 escaped，这种功能称之为“主动变量逃逸”。</p>
<p>实现主动变量逃逸比较简单，以 set 和 get 操作为例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不过别忘记了 Proxy 的那些 Invariants 限制，上述这些操作的结果都要反应到 target 身上，所以最后还是得把原始对象（如 window）上的属性同步到 target 上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-函数属性上下文"><a href="#2-3-函数属性上下文" class="headerlink" title="2.3 函数属性上下文"></a>2.3 函数属性上下文</h3><p>上面提到，我们需要把原始对象（window、document）的属性同步到 target 对象中，Proxy 才会不受到 Invariants 的影响，能更真实的模拟读写操作。</p>
<p>我们看下面一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/nhtwo0x2/4/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>再来看这样一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/1buvLtag/2/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>有这样一类函数，它们只能在指定的上下文中执行，即便是 Proxy 也不可以，否则在 Chrome 下就会报告 <strong>Illegal invocation</strong> 错误。在 Firefox 和 Safari 上的错误信息会更通俗易懂一些。</p>
<p>目标没有很好的办法来解决这个问题，毕竟函数内部的逻辑是无法预测的，只能尽可能兼容。一些策略有：</p>
<ul>
<li>如果属性名是 constructor，无需特殊处理；</li>
<li>如果属性名以大些字母开头， <strong>认为它们是构造函数</strong> ，无需特殊处理；</li>
<li>创建包装函数来锁定上下文:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newValueInTarget = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">unknown</span>[]</span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="comment">// 小写字母也可能是构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(valueInRaw, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(valueInRaw, raw, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一些特殊属性的处理，例如 window 上的 eval、isFinite、isNaN、parseFloat、parseInt、hasOwnProperty、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent，直接走主动变量逃生即可</li>
</ul>
<h2 id="三、执行-JavaScript-代码"><a href="#三、执行-JavaScript-代码" class="headerlink" title="三、执行 JavaScript 代码"></a>三、执行 JavaScript 代码</h2><p>上面讨论的是沙箱的最关键能力——变量隔离，但无论实现怎样的能力，子应用的 JS 代码还是要得到执行，那么该如何执行的？</p>
<h3 id="3-1-eval"><a href="#3-1-eval" class="headerlink" title="3.1 eval"></a>3.1 eval</h3><p>业界普遍的做法是异步 fetch 到源代码，然后 eval 它，虽然需要跨域环境的支持，但并不是难事。只是 eval 需要一些技巧。</p>
<p>首先，eval 需要在真正的 window 上下文中执行，避免调用环境的影响，这一点，目前已经有比较明确的实现方案，就是“间接调用”：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evalScript</span>(<span class="params">code: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span>, <span class="built_in">eval</span>)(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，利用函数入参来改变一些全局变量名的作用域，将其指向既定的对象，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, self, parent, top, globalThis, document) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.window, winProxy.self, winProxy.parent, winProxy.top, winProxy.globalThis, winProxy.document)`</span>);</span><br></pre></td></tr></table></figure>

<p>从这里也能看出，如果直接引用如 location、navigator、history 将无法被沙箱捕获，你需要用 window.location、window.navigator、window.history 的方法。进而可以推断出你在全局定义的变量，也必须以 window 属性的方式来读取，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span> <span class="attr">entry</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>像上面这种 case，如果不以 window.loadStartTime 的方式能不能读取得到呢？也有一些技巧可做到。</p>
<p>比如使用嵌套递归作用域的方式来实现，相当于每执行一次 JS 之后，就会为下一次执行生成一个新的嵌套上下文，这样后面的 JS 就可以直接读取上次的变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现机理稍有复杂，理论上也会带来额外的性能开销，而且对于下面这种双向访问的场景也无法支持：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendLog</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 访问未预定义变量</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">sendToServer</span>(&#123; loadCost &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过仍然具有一定的价值，对于以 HTML 作为 entry 的子应用的容纳范围更广，子应用的灵活度更高。</p>
<h3 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h3><p>有时，需要暴露给子应用的 JS 一些临时的虚拟变量，比如 qiankun 提供的 _<strong>_POWERED_BY_QIANKUN__</strong> ，而且允许不同子应用读取到的同一名称的变量有不同的取值。</p>
<p>如果不开启沙箱的话，这一功能反而困难，需要在 window 上定义变量，然后以同步的形式运行子应用 JS 代码，最后在从 window 上移除掉。这个过程不但很可能和 window 上已经有的同名变量冲突，而且也只能保证同步代码中能读取到，异步代码中就读不到。举例说明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在沙箱环境中，实现环境变量更简单，而且可以不受同步&#x2F;异步的影响，可以持续访问。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, document, __IN_MICRO_ENV__) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.document, winProxy.__IN_MICRO_ENV__)`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-ESM"><a href="#3-3-ESM" class="headerlink" title="3.3 ESM"></a>3.3 ESM</h3><p><strong>ESM</strong> 格式的 JS 代码不能直接 eval 来执行。事实上，浏览器还未提供能直接运行 ESM 源码的方法。Garfish 采取来将源码转换成 URI 的方式实现了一定程度的 eval 能力，但是需要正则匹配 import 指令，存在一定的隐患。即便如此，因为不能用函数直接封装 ESM 源码，因此也无法实现沙箱运行。因此，garfish 还实现了一套运行时转译 ESM 的机制，但是对性能有较大影响，相信其稳定性也存在安全隐患。</p>
<h2 id="四、DOM-结构"><a href="#四、DOM-结构" class="headerlink" title="四、DOM 结构"></a>四、DOM 结构</h2><p>一般来说，子应用有自认为的 DOM 环境，比如 html、body、head 以及#app 等等。</p>
<h3 id="4-1-固定-DOM"><a href="#4-1-固定-DOM" class="headerlink" title="4.1 固定 DOM"></a>4.1 固定 DOM</h3><p>在沙箱环境中，如果把真正的 html、body、head 暴露给子应用，那么它很有可能在上面做一些副作用的操作，比如插入新 DOM、修改样式等等。为了避免这种情况，微前端框架一般都会给子应用生成一个模拟的 DOM 结构，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pseudo-html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pseudo-title</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-body</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pseudo-html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DOM API 中的 <strong>document.documentElement</strong> 、 <strong>document.body</strong> 、 <strong>document.head</strong> 也都指向它们。</p>
<p>根据业务需求，可以做更深的伪装定制，通过以下测试：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">tagName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">nodeName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">version</span> === <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentNode</span> === <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentElement</span> === <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHtmlElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHtmlElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">tagName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">nodeName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">constructor</span> === <span class="title class_">HTMLBodyElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLBodyElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">tagName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">nodeName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHeadElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHeadElement</span> === <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>注意 <strong>document.documentElement.parentElement</strong> ，如果等于 null，可能对一些视觉框架、组件库等需要用 parentElement 向上递归搜索的功能不友好。可根据需要是否开启以上伪装能力。</p>
<h3 id="4-2-存量-DOM"><a href="#4-2-存量-DOM" class="headerlink" title="4.2 存量 DOM"></a>4.2 存量 DOM</h3><p>存量 DOM 是指那些在子应用的 HTML entry 中已有的 DOM 结构，简单的如#app，也可能有更复杂的结构。</p>
<p>通常需要把它们同步到上述固定 DOM 的 body 中，也有些方案把 head 中的 meta 都同步了过来。</p>
<p>一旦需要拷贝，需要考虑如下问题：</p>
<ul>
<li>非法元素、样式的过滤；</li>
<li>元素在沙箱环境的适配</li>
</ul>
<h3 id="4-3-新增-DOM"><a href="#4-3-新增-DOM" class="headerlink" title="4.3 新增 DOM"></a>4.3 新增 DOM</h3><p>新增 DOM 有多种创建方式：</p>
<ul>
<li>document.createElement()；</li>
<li>dom.clone()；</li>
<li>dom.innerHTML&#x3D;</li>
</ul>
<p>通常来说只有第一种会被沙箱接管，使得新创建的 DOM 的 ownerDocument、baseURI 是符合沙箱环境的。</p>
<p>需要特别关注的是，新创建的 script 元素会被转换成一个无实际功能的&lt;pseudo-script&gt;元素。框架会在后台自行下载&#x2F;执行其代码，模拟了 script 的能力。</p>
<p>Custom Element默认是inline类型，除了在shadow DOM内部使用 <strong>:host{display:block}</strong> 外，只能在外部用选择器覆盖。未来如果Safari支持<a href="https://caniuse.com/custom-elementsv1" target="_blank">继承built-in元素</a>后可以解决。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>沙箱只能处理有限范围内的变量隔离，通常为 window 和 document；</li>
<li>以 eval function 的方式执行 JS 源码，全局变量引用应以 window 属性的方式使用；ESM 无法支持沙箱；</li>
<li>子应用的 DOM 结构可以被伪装，但仍然能轻易实现逃逸</li>
</ul>
<p><strong>沙箱的本质是为子应用打造一个微型的独立浏览器环境，受限于成本，无法做到尽善尽美，仍然需要子应用遵循一定的规范和约定</strong> 。而由于微前端的主、子应用在管理上的独立性，往往沙箱能力的升级会对子应用造成较大的影响。</p>
<h2 id="六、未来发展"><a href="#六、未来发展" class="headerlink" title="六、未来发展"></a>六、未来发展</h2><p>业界对沙箱的实现均强依赖 Proxy 技术，区别仅在于对副作用的拦截能力多少。随着业务复杂度的提升，以及一些存量旧业务在遵循冲突约定的改造成本上的考虑，逐渐意识到 Proxy 的能力仍然有限，想实现健壮性更强的沙箱环境，开发成本高且性能不稳定。</p>
<p>业界已经有一些方案开始逐渐回归 iframe。iframe 天生具有强隔离性，不必对全局变量一一关注即可达到期望的隔离性能。不过这种一刀切的做法在实际的业务中仍然受到挑战，比如对主动逃逸变量的支持，比如对 DOM 的操作等等，仍然需要一定的机制将 iframe 和主页面整合到一起。这一步，仍然离不开 Proxy 的支持。</p>
<p>ECMA 已经有一个新的提案，叫做<a href="https://github.com/tc39/proposal-shadowrealm" target="_blank">ShadowRealm</a>，位于 Stage3，对于创建独立的 JS 执行环境是一个比较理想的方案。不过微前端离不开视图，如何共享视图对象以及控制共享的粒度，就不是 ShadowRealm 的范围了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/" data-id="clcve91ko00022a2v945g6gae" data-title="沙箱是如何工作的" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2022-04-20-keep-efficient-when-dont-known-what-doing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/" class="article-date">
  <time class="dt-published" datetime="2022-04-20T07:26:55.000Z" itemprop="datePublished">2022-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%92%A8%E8%AF%A2%E7%9A%84%E5%A5%A5%E7%A7%98/">咨询的奥秘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/">《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="没坏的话就不要修"><a href="#没坏的话就不要修" class="headerlink" title="没坏的话就不要修"></a>没坏的话就不要修</h2><p>这里讲的系统应该能够治愈。不过在现实场景中不太可能，即使可能在时效性上也不允许。</p>
<p>如果这里我们把这句话理解成：<strong>不要瞎折腾，没事找事</strong>，显然有一种消极的态度，如果一直安于现状，就会阻断创新。</p>
<p>从咨询师的角度来看更容易理解这句话，咨询师是系统的“外来物”，不是对于系统出现的所有问题都要横加干涉，适当的放任反而有益于系统的成长。可以借着下一句话来深入理解：</p>
<h2 id="反复治疗一个可以治愈的系统最终让它不能治愈"><a href="#反复治疗一个可以治愈的系统最终让它不能治愈" class="headerlink" title="反复治疗一个可以治愈的系统最终让它不能治愈"></a>反复治疗一个可以治愈的系统最终让它不能治愈</h2><p>引用书中的一句话就能轻松解释：</p>
<blockquote>
<p>那些孩子四岁多了还帮忙擦鼻子的父母，以及靠为同一个客户反复解决同一个问题混饭吃的顾问，都应该牢记这个秘密。</p>
</blockquote>
<p>那是那句话，不是都有问题都要横加干涉。否则最终会超出自己的能力范畴。</p>
<h2 id="每个处方都包含两部分：药品和正确使用它的方法"><a href="#每个处方都包含两部分：药品和正确使用它的方法" class="headerlink" title="每个处方都包含两部分：药品和正确使用它的方法"></a>每个处方都包含两部分：药品和正确使用它的方法</h2><p>我能把它理解成：“文档很重要，是产品的一部分”么？</p>
<p>我们在提供服务的时候，除了服务实体本身之外，还需提供使用说明。某些领域会提到以代码自注释能力来衡量代码的优劣，我觉得有一定道理但不是全部。</p>
<p>简单的系统确实可以做到轻松上手的目的，但也仅限于简单的系统。</p>
<h2 id="如果已经做过的事情没能解决问题，就告诉他们做点别的"><a href="#如果已经做过的事情没能解决问题，就告诉他们做点别的" class="headerlink" title="如果已经做过的事情没能解决问题，就告诉他们做点别的"></a>如果已经做过的事情没能解决问题，就告诉他们做点别的</h2><p>好打浑的说辞，不过确实有效。系统的某些问题往往出乎所有人意外，如果不能亲身实地地验证，仅仅依赖现有经验的人脑逻辑推断，确实不一定能够做出最终的诊断。</p>
<p>所以，在走投无路的时候，要学会接纳那些看似绝对无效的方案，说不定有意外的收获。</p>
<h2 id="务必让他们付给你足够多的钱，这样他们才会照你说的去做"><a href="#务必让他们付给你足够多的钱，这样他们才会照你说的去做" class="headerlink" title="务必让他们付给你足够多的钱，这样他们才会照你说的去做"></a>务必让他们付给你足够多的钱，这样他们才会照你说的去做</h2><p>就像练习书法用廉价的草纸会比用昂贵的字帖更不容易练好一样，只有你付出的成本更高，你才会更加专注和认真，因为失败的损失更大。</p>
<p>有另一种基于责任归属的解释，如果用字帖还练不好书法，那么将无法将责任落在纸的种类身上。</p>
<p>因此，通过提高任务的成本和消耗，将更有可能让执行脉络贴近自己的设计。</p>
<h2 id="来得早不如来得巧"><a href="#来得早不如来得巧" class="headerlink" title="来得早不如来得巧"></a>来得早不如来得巧</h2><p>时机很重要。</p>
<h2 id="【伯登法则】要是你不能改掉缺点，就把它变成特点"><a href="#【伯登法则】要是你不能改掉缺点，就把它变成特点" class="headerlink" title="【伯登法则】要是你不能改掉缺点，就把它变成特点"></a>【伯登法则】要是你不能改掉缺点，就把它变成特点</h2><p>这一法则将适用很多行业黑话，比如公司提供晚餐意味着加班更多。产品的特性从不同的视角可能会有截然相反的描述，核心原则就是避重就轻。这不一定就是一种欺骗，因为很可能那些未提及的缺陷对客户压根没有影响，或者打一个时间差，等客户发现了的时候，缺陷已经被修复，如果是可能甚至还可以是付费升级。</p>
<h2 id="【镀金法则】要是没法当成特点来宣扬，那就冒充一下"><a href="#【镀金法则】要是没法当成特点来宣扬，那就冒充一下" class="headerlink" title="【镀金法则】要是没法当成特点来宣扬，那就冒充一下"></a>【镀金法则】要是没法当成特点来宣扬，那就冒充一下</h2><p>这是“扒瞎”的意思吗？也许有作用，只要没人拆台和较真。对于聚集了大量耿直的人的行业中，可能风险性较大。</p>
<p>如果仅仅是电视广告在那里“镀金”的话，相信很少有人会真的打电话投诉；如果在一个小型的会议现场胡说八道，我想大概率会被“怼”。</p>
<p>这种缺乏货真价实干货的纯语言技巧，肯定不能撑太久。因此才会有下一句：</p>
<h2 id="所有镀金的东西都得改正"><a href="#所有镀金的东西都得改正" class="headerlink" title="所有镀金的东西都得改正"></a>所有镀金的东西都得改正</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/" data-id="clcve91ke00002a2v3lys9chk" data-title="《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-09-21-prettier-eslint" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/21/2018-09-21-prettier-eslint/" class="article-date">
  <time class="dt-published" datetime="2018-09-21T09:24:25.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/21/2018-09-21-prettier-eslint/">prettier配合eslint执行自动化代码格式化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://eslint.org/">eslint</a> 早已取代 <a target="_blank" rel="noopener" href="https://www.jslint.com/">jslint</a> 成为了 JavaScript 标准的风格检查工具，提供了大量规则（rule）。这些规则部分是可以支持 <em>fixable</em> 的，也就是说可以自动修复代码。但是现在来看，eslint 提供的修复功能还是太弱。因此 Facebook 开发了 <a target="_blank" rel="noopener" href="https://prettier.io/">prettier</a>，一个专门司职代码格式化的工具，它不仅仅支持 JavaScript 语法，甚至还支持 Markdown。因此，把它们配合起来是一种自然而然的想法，首先我们有一个 eslint-config 定义，我们希望经过 format 之后的代码能100%通过 lint 校验。我们也希望在 git hook 中能自动 format 代码。</p>
<p>在实际应用中，让 prettier 完美配合 eslint 并不容易。根本原因在于 prettier 格式化代码的一些行为是不可配置的，而这些配置极有可能与 eslint 配置是冲突的。</p>
<p>例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span> || b === <span class="number">2</span> || c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 eslint 中，我们经常配置在折行时把符号写在前边：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span></span><br><span class="line">|| b === <span class="number">2</span></span><br><span class="line">|| c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但 prettier 则强行写在后面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span> ||</span><br><span class="line">b === <span class="number">2</span> ||</span><br><span class="line">c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>prettier 提供了与 eslint 配合使用的<a target="_blank" rel="noopener" href="https://prettier.io/docs/en/eslint.html">官方方法</a>。但这种方式的本质是使用 eslint-config-prettier 来抹平 prettier 与 eslint 之间不可调和的冲突。一旦我们定义的私有 eslint-config 与 eslint-config-prettier 有影响格式化结果的冲突，那么 lint 必然失败。不过这种方式的一大好处是仅仅对接 eslint 就能完成 lint 与 fix 的操作，集成性很强。</p>
<p>理解这种现象很容易，eslint 的 rules 是没有顺序的，因此在 fix 阶段，极有可能 prettier 的 rule 执行在最后阶段，结果显然与我们定义的最终 eslint 配置是冲突的。</p>
<hr>
<p>相比于引用一系列 eslint-config，并维护它们的顺序，我们索性只维护我们自己的一份 eslint-config，反而更清晰。有这一份配置来执行 fix，产出一定可以通过lint。</p>
<p>但我们肯定不想直接抛弃 prettier，那么就把它的执行放在最前面，让它的产出再通过 eslint 即可。</p>
<p>已经存在这种现成的解决方案，就是 <a target="_blank" rel="noopener" href="https://github.com/prettier/prettier-eslint">prettier-eslint</a>。虽然看起来比较畸形，但可能是唯一一种比较能用且清晰的方案了。</p>
<p>但也有缺点，一旦将来某些 prettier 的不可配置的行为也不能被 eslint 所 fix，工作流就 gg 了。整合的过程就是这样，本来是相互分离的两个系统，让它们一起工作，总要失去点什么。</p>
<blockquote>
<p>Code ➡️ prettier ➡️ eslint –fix ➡️ Formatted Code ✨</p>
</blockquote>
<p>Q：如果能保证 prettier 提供的 rule 能先行执行呢？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/09/21/2018-09-21-prettier-eslint/" data-id="cl1ul7d72003ajc2vdr7n3xo0" data-title="prettier配合eslint执行自动化代码格式化" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-03-23-principle-+" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/23/2018-03-23-principle-+/" class="article-date">
  <time class="dt-published" datetime="2018-03-23T07:02:57.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/23/2018-03-23-principle-+/">Javascript &#39;+&#39; 运算符原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>继了解完“&#x3D;&#x3D;”的原理后，再来了解一下加号“+”的 ECMAScript 实现原理。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure>

<p>第一步，对 a 和 b 执行 *toPrimitive()*，不指定 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-ordinarytoprimitive">hint</a>。</p>
<p>以 <em>toPrimitive(a)</em> 为例，先看 a 有没有定义 <em>Symbol.toPrimitive</em>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = customToPrimitive;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customToPrimitive</span>(<span class="params">hint</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">            ...</span><br><span class="line">        <span class="attr">default</span>: <span class="comment">// &#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果定义了 <em>Symbol.toPrimitive</em> 属性，则执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customToPrimitive.<span class="title function_">call</span>(a, <span class="string">&#x27;default&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>否则执行原生 *toPrimitive(“number”)*，也就是要依次调用 a 的 <em>valueOf</em> 和 <em>toString</em> 方法。</p>
<p>如果执行 <em>a.valueOf()</em> 返回不是 Object，则为 <em>toPrimitive(a)</em> 的终值，否则执行 *a.toString()*。</p>
<p>接下来，看 a 有没有定义 toString，如果有，则执行 *a.toString()*，为 <em>toPrimitive(a)</em> 的终值。</p>
<p>如果没有，则执行原型链顶端的 <em>Object.prototype.toString</em>,这首先要看 a 有没有定义 <em>Symbol.toStringTag</em>。</p>
<p>如果定义了，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customStringTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: customStringTag</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么返回 *”[object “ + customStringTag.apply(a) + “]”*，否则返回 *”[object Object]”*，为 <em>toPrimitive(a)</em> 的终值。</p>
<p>如果发现 <em>toPrimitive(a)</em> 或者 <em>toPrimitive(b)</em> 任一为字符串，则执行字符串拼接，否则执行数字加法，即 *toNumber(a) + toNumber(b)*，这也能解释 <strong>true + true &#x3D; 2</strong> 的问题。</p>
<hr>
<p>可见 <em>a + b</em> 核心就是 <em>toPrimitive</em> 操作，只不过从 ES2015 以来，<em>toPrimitive</em> 受到 Symbol 的影响，变得越来越复杂。</p>
<p>相比之下，减号“-”就很简单了，就是执行 *toNumber(a) - toNumber(b)*。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/03/23/2018-03-23-principle-+/" data-id="cl1ul7d710038jc2vajqea0y5" data-title="Javascript &#39;+&#39; 运算符原理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-27-cultivating-a-paradoxical-frame-of-mind" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/" class="article-date">
  <time class="dt-published" datetime="2018-02-27T08:43:11.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%92%A8%E8%AF%A2%E7%9A%84%E5%A5%A5%E7%A7%98/">咨询的奥秘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/">《咨询的奥秘》 第二章 培养矛盾的思维框架</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对于社会主义的中国人来讲，经过初中、高中、大学的思想政治课的洗礼，理解矛盾并非难事，我们辩证唯物主义的内容要更丰富得多。</p>
<h1 id="第二章-培养矛盾的思维框架"><a href="#第二章-培养矛盾的思维框架" class="headerlink" title="第二章 培养矛盾的思维框架"></a>第二章 培养矛盾的思维框架</h1><h2 id="不要理性，要合理"><a href="#不要理性，要合理" class="headerlink" title="不要理性，要合理"></a>不要理性，要合理</h2><p>这两个相似的词忽然让我很难揣摩这句只包含6个字的话。什么样的事情是合理但不理性的呢？我理解，理性是对事件真实客观的描述，是能用逻辑严格证明的，往往获取“理性”需要很大的成本，甚至在有意义的时间内无法获取；而合理则是一种模棱两可的适当妥协，在有些事情无法获取“理性”之时，委曲求全的权宜之计都可能是一种合理。合理是一种“反牛角尖的”行为，似乎更倾向于“糊弄”。</p>
<p>在作者涉猎的软件咨询行业，很难想象不求甚解的方案也能行得通。从技术上来讲，确实再隐晦的故障都是可以绝对定位的，但对于项目来说，往往最初的设计和真正的落地会有很大差距，如果没有绝对的经验积累，那么项目在循循渐进的过程中往往都会带着猜的成份。换句话说，没有理性，只要比上一版本又说改进，即为合理。从这角度上来说，一味得追求最佳既是不可能的任务，也不能称之为理性的抉择，毕竟世界是个矛盾体，在矛盾中寻求理性的过程收获利益，才是上上之选。</p>
<p>从这里可以衍生出一种经典的产品进化模型，比如想造一辆汽车，下面有两种方案：</p>
<ol>
<li>第一种，先造轮子、发动机、车架，最终拼接成完善的汽车；</li>
<li>第二种，先造一辆自行车、摩托车、三轮车，最后一辆汽车</li>
</ol>
<p>第二种方案看似费时费力，往往更容易被人接受，也更容易实现。</p>
<h2 id="自以为无所不知的人最容易上当"><a href="#自以为无所不知的人最容易上当" class="headerlink" title="自以为无所不知的人最容易上当"></a>自以为无所不知的人最容易上当</h2><p>过于自信就是自负，往往容易对客观事实视而不见。这和“撞车的都是老司机”、“淹死的都是会水的”是类似的道理。</p>
<h2 id="生活太重要，所以不能太较真"><a href="#生活太重要，所以不能太较真" class="headerlink" title="生活太重要，所以不能太较真"></a>生活太重要，所以不能太较真</h2><p>这论题太大了，似乎已经上升到了哲学和三观的高度上来了。我想作者要表达的意思应该是，对于无法解释的事物不必过于在意，毕竟你的无知正是矛盾世界里的必不可少的成份。</p>
<h2 id="不付出就什么也得不到"><a href="#不付出就什么也得不到" class="headerlink" title="不付出就什么也得不到"></a>不付出就什么也得不到</h2><p>正是矛盾的合理体现，要想得到什么，不可避免地要失去什么，当然，反过来不一定成立，往往都不成立。</p>
<h2 id="提升一方面，就要牺牲另一方面"><a href="#提升一方面，就要牺牲另一方面" class="headerlink" title="提升一方面，就要牺牲另一方面"></a>提升一方面，就要牺牲另一方面</h2><p>同上</p>
<h2 id="费舍基本定理——你越适应现状，就越难适应变化"><a href="#费舍基本定理——你越适应现状，就越难适应变化" class="headerlink" title="费舍基本定理——你越适应现状，就越难适应变化"></a>费舍基本定理——你越适应现状，就越难适应变化</h2><p>显然，与现有系统耦合越大，与其它系统兼容越小。抽象与具象。</p>
<blockquote>
<p>伴随着年纪的增长，我觉得自己就越来越难以适应变化。</p>
</blockquote>
<h2 id="顾问一般在解决你提出的第三个问题时最有成效"><a href="#顾问一般在解决你提出的第三个问题时最有成效" class="headerlink" title="顾问一般在解决你提出的第三个问题时最有成效"></a>顾问一般在解决你提出的第三个问题时最有成效</h2><p>这也解释了为什么人在20多岁的时候最富创造性，因为年老后才更“善于”和这个“平庸”的世界打交道。</p>
<p>始终关注自己在什么时候拥有最高效的进步，在合适的时候，应当勇于舍弃舒适的温床。</p>
<blockquote>
<p>我确实应该换个工作了🍟</p>
</blockquote>
<h2 id="我们能做，这是所需的费用"><a href="#我们能做，这是所需的费用" class="headerlink" title="我们能做，这是所需的费用"></a>我们能做，这是所需的费用</h2><p>没有成本的改变是不现实的，懂得这个道理，避免在愚蠢的任务上浪费时间与口舌。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/" data-id="cl1ul7d6z0035jc2vd45t8opq" data-title="《咨询的奥秘》 第二章 培养矛盾的思维框架" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-19-pagex" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/19/2018-02-19-pagex/" class="article-date">
  <time class="dt-published" datetime="2018-02-19T10:00:15.000Z" itemprop="datePublished">2018-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/19/2018-02-19-pagex/">获取元素在文档流中的位置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>元素在文档流中的位置应与页面滚动量无关，指的是该元素左上角（包括border，但不包括margin）距离整个页面左上角的水平和垂直位置。</p>
<p>获取此位置有两种方法，观察 <a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/blob/2.2-stable/src/offset.js#L101">jQuery 2.2 源码</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = elem.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="keyword">var</span> win = elem.<span class="property">ownerDocument</span>.<span class="property">defaultView</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">top</span>: rect.<span class="property">top</span> + win.<span class="property">pageYOffset</span>,</span><br><span class="line">    <span class="attr">left</span>: rect.<span class="property">left</span> + win.<span class="property">pageXOffset</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>getBoundingClientRect</code> 是一个十分高效的方法，用来获取元素相对于可见的视口的位置，而这个位置是与滚动量有关的，只有这个位置加上滚动量，即是与文档左上角的距离。</p>
<p>如果 <code>getBoundingClientRect</code> 不存在，我们依然可以通过遍历计算出结果。首先需要了解 DOM 元素的几个属性：</p>
<ol>
<li>offsetParent 向上祖先中第一个定位元素；</li>
<li>offsetLeft 距离 offsetParent 左边界的水平位置，与滚动量无关</li>
<li>offsetTop 距离 offsetParent 上边界的垂直位置，与滚动量无关</li>
<li>clientLeft 一般为左边框宽度</li>
<li>clientTop 一般为上边框宽度</li>
<li>scrollLeft 水平滚动距离</li>
<li>scrollTop 垂直滚动距离</li>
</ol>
<p>因为我们要得到的距离是当时的绝对距离，与该元素的各个祖先元素的滚动量是有关的，因此我们不能简单地通过加和 <em>offsetLeft</em> 与 <em>offsetTop</em> 来得到最后的值，必须减去每一级祖先的滚动量。</p>
<p>具体逻辑大概就是，向该元素的上面遍历，减去每个元素的滚动量，一旦遇到是 <em>offsetParent</em>，则加上 <em>offsetLeft</em> 与 <em>offsetTop</em>。具体可参考 <a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/blob/1.4.4/src/offset.js#L79">jQuery 1.4.4 源码</a>。简单来讲就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">offset</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> top = ele.<span class="property">offsetTop</span>;</span><br><span class="line">    <span class="keyword">var</span> left = ele.<span class="property">offsetLeft</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offsetParent = ele.<span class="property">offsetParent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ele = ele.<span class="property">parentNode</span>) &amp;&amp; ele !== <span class="variable language_">document</span>) &#123;</span><br><span class="line">        left -= (ele.<span class="property">scrollLeft</span>);</span><br><span class="line">        top -= (ele.<span class="property">scrollTop</span>);</span><br><span class="line">        <span class="keyword">if</span> (offsetParent === ele) &#123;</span><br><span class="line">            top += ele.<span class="property">offsetTop</span> + ele.<span class="property">clientTop</span>;</span><br><span class="line">            left += ele.<span class="property">offsetLeft</span> + ele.<span class="property">clientLeft</span>;</span><br><span class="line">            offsetParent = offsetParent.<span class="property">offsetParent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;top,left&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然 clientTop 与 clientLeft 并非永远代表的是上边框和左边框的宽度。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/19/2018-02-19-pagex/" data-id="cl1ul7d6y0033jc2vdr2xflz2" data-title="获取元素在文档流中的位置" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-12-vue-dom-diff" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/12/2018-02-12-vue-dom-diff/" class="article-date">
  <time class="dt-published" datetime="2018-02-12T06:41:01.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/12/2018-02-12-vue-dom-diff/">Vue.js 中的 DOM Diff 算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一篇我们熟悉了一下 <em>Inferno.js</em> 的 DOM Diff 算法。今天我们来看 <a target="_blank" rel="noopener" href="https://vuejs.org/">Vue.js</a> 框架的 DOM Diff 算法。</p>
<p><em>Vue.js</em> 的作者没有编写自己的算法，而是使用了 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">Snabbdom</a>，并做了适当的修改。</p>
<p>DOM Diff 的关键算法在 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom/blob/v0.7.1/src/snabbdom.ts#L179">https://github.com/snabbdom/snabbdom/blob/v0.7.1/src/snabbdom.ts#L179</a>。</p>
<p>同样，我们依然假设有原始的 DOM 集合A为 “<em>dfibge</em>”，更新后的集合B为 “<em>igfheb</em>”。</p>
<p>创建4个指针 <em>oldStartIdx</em>、<em>oldEndIdx</em>、<em>newStartIdx</em>、<em>newEndIdx</em>，初始分别指向A的起始点、结束点和B的起始点、结束点。显然：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oldStartIdx=<span class="number">0</span></span><br><span class="line">oldEndIdx=<span class="number">5</span></span><br><span class="line">newStartIdx=<span class="number">0</span></span><br><span class="line">newEndIdx=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>第一步，比较 A[oldStartIdx] 和 B[newStartIdx]，如果相同，则 oldStartIdx++、newStartIdx++。<br>第二步，比较 A[oldEndIdx] 和 B[newEndIdx]，如果相同，则 oldEndIdx++、newEndIdx++。</p>
<p>在本例中，以上两步全部不满足，跳过。</p>
<p>第三步，比较 A[oldStartVnode] 和 B[newEndVnode]，如果相同，则节点发生了右移。<br>第四步，比较 A[oldEndIdx] 和 B[newStartIdx]，如果相同，则节点发生了左移。</p>
<p>在本例中，以上两步全部不满足，跳过。</p>
<p>第五步，在A中搜索 B[newStartIdx]，即 <em>i</em>，找到则把A中的 <em>i</em> 移到 A[oldStartVnode] 前面并 newStartIdx++、oldStartVnode++，否则则创建它。</p>
<p>在本例中，A变成 <em>idfbge</em>。</p>
<p>返回第一步。</p>
<hr>
<p>可以看到这个算法类似于优化后的插入排序。按照此算法，A的变换路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">A:dfibge</span><br><span class="line">B:igfheb</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:idfbge</span><br><span class="line">B:igfheb</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igdfbe</span><br><span class="line">B:igfheb</span><br><span class="line">   ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfdbe</span><br><span class="line">B:igfheb</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhdbe</span><br><span class="line">B:igfheb</span><br><span class="line">     ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhedb</span><br><span class="line">B:igfheb</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhebd</span><br><span class="line">B:igfheb</span><br><span class="line">       ^</span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfheb</span><br><span class="line">B:igfheb</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>

<p>用一句话概括此算法的核心就是：依次遍历B集合，在A集合中找到对应项，放到与在B集合中相同的位置上。只不过 <em>Snabbdom</em> 使用了双向同时遍历来进行优化。</p>
<p>事实上，React 的 DOM Diff 算法与此也是非常类似的，只不过受限于 Fiber，只进行了单向搜索。但是即便如此， React 也引入了优化策略，尽量使得更多的元素不必移动。从本质上来看，Inferno 和 React 都利用递增子序列来进行了优化，但是 Inferno 使用算法来保证是最大递增子序列，而 React 的子序列是一定从第一个元素开始的，因此不一定是最大子序列。这在尾部元素移动到首部的时候，差异表现得更明显。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/12/2018-02-12-vue-dom-diff/" data-id="cl1ul7d6x0030jc2v2a9tac6l" data-title="Vue.js 中的 DOM Diff 算法" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-11-inferno-dom-diff" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/11/2018-02-11-inferno-dom-diff/" class="article-date">
  <time class="dt-published" datetime="2018-02-11T10:20:59.000Z" itemprop="datePublished">2018-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/11/2018-02-11-inferno-dom-diff/">Inferno.js 中的 DOM Diff 算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>已经关注 <a target="_blank" rel="noopener" href="https://infernojs.org/">Inferno.js</a> 有两年的时间，终于在刚刚不久的过去建立起了官网和文档。</p>
<p>值得特别关注的是，<em>Inferno.js</em> 提供了类 React API 的同时，在 DOM Diff 算法上借鉴了 <a target="_blank" rel="noopener" href="https://github.com/ivijs/ivi">ivijs</a>，取得了更高的效率，从而有较强的性能表现。</p>
<p>优秀的 DOM Diff 算法的核心都是在将一个 DOM 集合转换成另一个 DOM 集合的同时，尽可能地复用已有 DOM 并具有较少的 DOM 移动操作，这是由于 DOM 操作（甚至访问）的成本较高。</p>
<p><em>Inferno.js</em> 在两个 VDom 之间进行比较，从而避免了频繁访问 DOM 的性能开销。下面我们看一下它实现的 DOM Diff 算法。</p>
<p>我们假设有原始的 DOM 集合A为 “<em>dfibge</em>”，更新后的集合B为 “<em>igfheb</em>”。</p>
<p>首先得到集合B中元素在A中的原始位置，如果在A中不存在则为-1，得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A       = [d, f, i,  b, g, e];</span><br><span class="line"><span class="keyword">var</span> B       = [i, g, f,  h, e, b];</span><br><span class="line"><span class="keyword">var</span> sources = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>现在我们获取该数组的最大递增子序列的序列位置，为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seq = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>];<span class="comment">// [2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>这个数组的意义在于：“新数组中第0、1、4位置的元素在原始数组中是无需移动的”，这是我们能获取最小移动步数的关键。</p>
<blockquote>
<p>一共6个成员，3个无需移动，那么一定有3个需要操作</p>
</blockquote>
<p>现在我们从后往前遍历集合B，观察每个成员的位置是否存在于 <em>seq</em> 中，存在则不必操作，不存在则需移动。</p>
<p>首先我们需要先删除B中存在，但A中不存在的元素 <em>d</em>，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br></pre></td></tr></table></figure>

<p>观察B中最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">                  ^ pos=5</span><br></pre></td></tr></table></figure>

<p>位置是5，不存在于 <em>seq</em> 中，需要把集合A中的 <em>b</em> 移到最后，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, e, b] --- (1)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第二个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">               ^ pos=4</span><br></pre></td></tr></table></figure>

<p>位置是4，存在于 <em>seq</em> 中，无需操作。</p>
<p>观察B中倒数第三个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">            ^ pos=3</span><br></pre></td></tr></table></figure>

<p>在A中不存在，我们需要创建 <em>h</em>，并放到 <em>e</em> 的前面，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, h, e, b] --- (2)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第四个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, h, e, b]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">         ^ pos=2</span><br></pre></td></tr></table></figure>

<p>位置是2，不存在于 <em>seq</em> 中，需要把集合A中的 <em>f</em> 移到 <em>h</em> 的前面，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[i, g, f, h, e, b] --- (3)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第五个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[i, g, f, h, e, b]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">      ^ pos=1</span><br></pre></td></tr></table></figure>

<p>位置是1，存在于 <em>seq</em> 中，无需任何操作。</p>
<p>观察B中倒数第六个元素，也是最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">   ^ pos=0</span><br></pre></td></tr></table></figure>

<p>位置是0，存在于<em>seq</em>中，也无需任何操作。</p>
<p>此时，所有操作都已结束，仅需3步，集合A已经转换成了集合B。其中，对 <em>d</em> 的移除和对 <em>h</em> 的创建是不可避免的，除此之外，仅进行了两次DOM移动，也印证了上面提到的 6-3&#x3D;3 的操作步骤。</p>
<blockquote>
<p>我们在移动 DOM 的时候都是执行的“插在XXX之前”，是因为 DOM 中的 <em>insertBefore</em> 方法，如果存在 insertAfter，那么从前往后操作也是等效的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/11/2018-02-11-inferno-dom-diff/" data-id="cl1ul7d6w002yjc2v6y1qa9x1" data-title="Inferno.js 中的 DOM Diff 算法" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-07-js-inherits" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/06/2018-02-07-js-inherits/" class="article-date">
  <time class="dt-published" datetime="2018-02-06T13:37:24.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/06/2018-02-07-js-inherits/">JavaScript 中继承的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们都知道 JavaScript 是通过原型链继承的，在不支持 class、extends 语法的环境里，继承又该如何实现呢？</p>
<p>首先我们来整理实现继承后的效果表征，假设存在两个类（函数）A 和 B，我们要实现 B 继承于 A，那么需要满足：</p>
<ol>
<li>new B() instanceof A 为真；</li>
<li>B.prototype.constructor &#x3D;&#x3D;&#x3D; B 为真；</li>
<li>如果 A.foo &#x3D; 1，则 B.foo &#x3D; 1 为真，即静态变量可继承；</li>
<li>在普通方法 foo 中可以调用 super.foo() 调用基类方法；</li>
<li>在构造方法中可以调用 super() 调用基类构造方法</li>
</ol>
<p>在很多年前，jQuery 作者 <em>John Resig</em> 曾写过一个继承的<a target="_blank" rel="noopener" href="https://johnresig.com/blog/simple-javascript-inheritance/">实现</a>，在那个还在 ES3 语法的时代已经非常难得。在今天看来，这种实现方式的语义已经远远落后，同时也不能实现静态变量。</p>
<hr>
<p>下面我们来一步一步地去理解 babel 的实现方式。</p>
<p>首先定义两个类（函数），以及子类的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>想实现 B 继承于 A，那边必然 <em>b instanceof B</em> 为真，根据 instanceof 的意义，一定有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="property">__proto__</span>.<span class="property">__proto__</span>... === A.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>我们知道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="property">__proto__</span> === B.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>那么我们只需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>... === A.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>于是我们覆写 <em>B.prototype</em>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<p>这样一定有 <em>A.prototype.isPrototypeOf(B.prototype)</em> 为真。</p>
<p>现在我们已经实现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b <span class="keyword">instanceof</span> A === <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>也就是说第一条我们已经实现了，下面看第二条，只需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = B;</span><br></pre></td></tr></table></figure>

<p>或者更优雅一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在我们要实现静态成员的继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br></pre></td></tr></table></figure>

<p>目前为止，我们定义的是两个空类，现在我们为他们增加 name 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; B</span></span><br></pre></td></tr></table></figure>

<p>现在我们要在 B 的 name 中获取父类的 name 属性，那么我们就需要找到 B.prototype 中的 name。</p>
<p>在 B 环境中，灵活的做法是通过 B.prototype 找到 A.prototype，根据 *B.prototype &#x3D; Object.create(A.prototype)*，我们知道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<p>于是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">            <span class="keyword">var</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; AB</span></span><br></pre></td></tr></table></figure>

<p>这就实现了 super.name 的效果。当然，我们假设 B 的父类是定义了 name 的，如果没有找到 name，那应该沿着原型链继续向上寻找。因此更健壮的写法是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = B.<span class="property"><span class="keyword">prototype</span></span>, desc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(sup);</span><br><span class="line">                <span class="keyword">if</span> (!sup) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span>(!desc);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> (desc ? desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) : <span class="literal">undefined</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; AB</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里没有考虑 name 不是 getter 的情形，不过原理类似，不再冗述。</p>
</blockquote>
<p>最后我们来实现在构造方法中调用 super()。显然，实质是在 B 函数中找到函数 A，根据 *Object.setPrototypeOf(B, A)*，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B).<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为 A 添加一个 age 构造参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B).<span class="title function_">call</span>(<span class="variable language_">this</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = B.<span class="property"><span class="keyword">prototype</span></span>, desc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(sup);</span><br><span class="line">                <span class="keyword">if</span> (!sup) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span>(!desc);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> (desc ? desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) : <span class="literal">undefined</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>(<span class="number">18</span>).<span class="property">age</span>); <span class="comment">// =&gt; 18</span></span><br></pre></td></tr></table></figure>

<p>于是，一个基本的继承的手写版本就实现了，当然，babel 还考虑了更多细节，比如构造方法有返回值的情况等等，但基本的继承原理就是这个样子。</p>
<p>下图很好地反应了诸多对象的关系。值得一提的是， <em>b</em> 也可能成为下一级类的 prototype，你可以清晰地看到通过 __proto__ 搜索原型链的轨迹。</p>
<p><img src="/images/inherits/inherit.jpg" alt="js-inherit"></p>
<hr>
<p>在现代浏览器的不断迭代下，已经有大部分版本都实现了对 class 关键字和继承的原生支持，相信在不久的将来，就无需在这么麻烦地实现继承了。无论如何，JavaScript 继承的原理仍然是不变的，上面这些内容有助于理解原型链是怎么样工作的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/06/2018-02-07-js-inherits/" data-id="cl1ul7d6v002vjc2v9s9s0c45" data-title="JavaScript 中继承的实现" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018-02-06-is-plainobject" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/06/2018-02-06-is-plainobject/" class="article-date">
  <time class="dt-published" datetime="2018-02-05T23:21:44.000Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/06/2018-02-06-is-plainobject/">isPlainObject 的不同实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开头一个问题是：什么是 <code>Plain Object</code>？</p>
<p>并没有看到有官方去专门定义它，更可能它只不过是业界的一种通俗叫法，因此也没有严格的定义。但我们在汉语环境里通常叫它“纯对象”。</p>
<blockquote>
<p>业界解释：<a target="_blank" rel="noopener" href="https://www.quora.com/What-is-a-plainObject-in-JavaScript">https://www.quora.com/What-is-a-plainObject-in-JavaScript</a></p>
</blockquote>
<p>下面我们来看一下常见 Library 对 <em>isPlainObject</em> 函数的实现。</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>jQuery 3.3 版本中的 <em>isPlainObject</em> 定义在<a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/blob/3.3.0/src/core.js#L208">这里</a>。</p>
<p>为便于阅读，核心代码经过整理后如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPlainObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> proto, <span class="title class_">Ctor</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) null 肯定不是 Plain Object</span></span><br><span class="line">    <span class="comment">// (2) 使用 Object.property.toString 排除部分宿主对象，比如 window、navigator、global</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || (&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(obj) !== <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有从用 &#123;&#125; 字面量和 new Object 构造的对象，它的原型链才是 null</span></span><br><span class="line">    <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 如果 constructor 是对象的一个自有属性，则 Ctor 为 true，函数最后返回 false</span></span><br><span class="line">    <span class="comment">// (2) Function.prototype.toString 无法自定义，以此来判断是同一个内置函数</span></span><br><span class="line">    <span class="title class_">Ctor</span> = (&#123;&#125;).<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(proto, <span class="string">&quot;constructor&quot;</span>) &amp;&amp; proto.<span class="property">constructor</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="title class_">Ctor</span> === <span class="string">&quot;function&quot;</span> &amp;&amp; <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Ctor</span>) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Object</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h2><p>lodash 4.0.6 版本中的 <em>isPlainObject</em> 定义在<a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/blob/4.0.6-npm-packages/lodash.isplainobject/index.js#L125">这里</a>。</p>
<p>基本与 jQuery 版本相同，多了一个 <em>Ctor instanceof Ctor</em> 的条件，满足此条件的仅有 <em>Function</em> 和 <em>Object</em> 两个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPlainObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span> || (&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(value) != <span class="string">&#x27;[object Object]&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Ctor</span> = hasOwnProperty.<span class="title function_">call</span>(proto, <span class="string">&#x27;constructor&#x27;</span>) &amp;&amp; proto.<span class="property">constructor</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="title class_">Ctor</span> == <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title class_">Ctor</span> <span class="keyword">instanceof</span> <span class="title class_">Ctor</span> &amp;&amp; <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Ctor</span>) === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Object</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p>redux 从 4.0.0 开始在测试中使用了 <em>isPlainObject</em>，代码在<a target="_blank" rel="noopener" href="https://github.com/reactjs/redux/blob/v4.0.0-beta.1/src/utils/isPlainObject.js#L5">这里</a>。</p>
<p>它的实现比较简单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPlainObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> proto = obj</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proto = null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>我们并没有一个能判断 <em>Plain Object</em> 的清晰逻辑，大概能理出来的思路是：</p>
<ol>
<li>先判断 obj 本身是否满足我们熟悉的合法对象概念；</li>
<li>判断 obj 的构造函数是不是 Object</li>
</ol>
<p>至于判断 prototype 是不是 null，无非是一种 shortcut 罢了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yanni4night.github.io/2018/02/06/2018-02-06-is-plainobject/" data-id="cl1ul7d6u002ujc2vcu0d9iuf" data-title="isPlainObject 的不同实现" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/b70-Valkyrie/">b70 Valkyrie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bubble-event-jquery/">bubble event jquery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bug/">bug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/chrome-json-performance-resource-timing/">chrome json performance resource timing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css3-column-layout/">css3 column layout</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/encoding/">encoding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/engineering/">engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/error-exception-throw-try-catch-%E5%BC%82%E5%B8%B8/">error exception throw try catch 异常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flex-box-%E5%8F%AF%E4%BC%B8%E7%BC%A9-%E5%B8%83%E5%B1%80/">flex box 可伸缩 布局</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitbook-plugin/">gitbook plugin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/incremental-DOM-reactjs-emberjs-glimmer/">incremental DOM reactjs emberjs glimmer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/layout/">layout</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/liqi-%E5%88%A9%E5%99%A8/">liqi 利器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/npm/">npm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/npm-node-semser-%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/">npm node semser 语义化版本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/performance/">performance</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react-native/">react-native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sublime-plugin/">sublime plugin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tieba-https/">tieba https</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webcomponents/">webcomponents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%92%A8%E8%AF%A2%E7%9A%84%E5%A5%A5%E7%A7%98/">咨询的奥秘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E7%A8%8B%E5%B8%88-%E6%88%90%E9%95%BF/">工程师 成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/">微前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E5%8C%BA-%E6%8A%80%E6%9C%AF/">社区 技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/" rel="tag">other</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/other/" style="font-size: 10px;">other</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/14/2023-01-14-how-sandbox-works/">沙箱是如何工作的</a>
          </li>
        
          <li>
            <a href="/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/">《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效</a>
          </li>
        
          <li>
            <a href="/2018/09/21/2018-09-21-prettier-eslint/">prettier配合eslint执行自动化代码格式化</a>
          </li>
        
          <li>
            <a href="/2018/03/23/2018-03-23-principle-+/">Javascript &#39;+&#39; 运算符原理</a>
          </li>
        
          <li>
            <a href="/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/">《咨询的奥秘》 第二章 培养矛盾的思维框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Yanni4night<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
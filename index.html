<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yanni4night.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="人过不留名 雁过不留声">
<meta property="og:url" content="https://yanni4night.github.io/index.html">
<meta property="og:site_name" content="人过不留名 雁过不留声">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yanni4night">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yanni4night.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>人过不留名 雁过不留声</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">人过不留名 雁过不留声</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">夜莺</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yanni4night</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2024/01/10/2024-01-10-find-allan-poe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/10/2024-01-10-find-allan-poe/" class="post-title-link" itemprop="url">认识推理小说的奠基者——读《爱伦·坡短篇小说集》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-10 09:33:00" itemprop="dateCreated datePublished" datetime="2024-01-10T09:33:00+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-14 17:56:47" itemprop="dateModified" datetime="2024-01-14T17:56:47+08:00">2024-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><font size=1>本文首发于“莺见”微信公众号：<img src="/images/wx/wx.png" width="300" /></font></p>
</blockquote>
<br />

<p><font color=grey size=1>（全文4900字，阅读可能需要10分钟）</font></p>
<p>最近一个多月，机缘巧合地读了几本江户川乱步的侦探小说，得知包括柯南·道尔在内的这些推理作家，都或多或少地受到了美国作家<strong>爱伦·坡</strong>的影响。带着好奇的心情，从网上花了9块钱淘了一本《爱伦·坡短篇小说集》。</p>
<img src="/images/allan-poe/book.png" width="200" />

<p>这一本252页的书包含了11篇小故事：</p>
<ol>
<li>《红死魔的假面具》</li>
<li>《厄舍府的倒塌》</li>
<li>《一桶蒙特亚白葡萄酒》</li>
<li>《泄密的心》</li>
<li>《威廉·威尔逊》</li>
<li>《黑猫》</li>
<li>《莫格街凶杀案》</li>
<li>《失窃的信》</li>
<li>《金甲虫》</li>
<li>《瓶中手稿》</li>
<li>《乌鸦》</li>
</ol>
<p>我阅读过后的感受，怎么说呢，非常困惑，从两个方面来讲。</p>
<h2 id="文字晦涩，环境和心理刻画篇幅过多"><a href="#文字晦涩，环境和心理刻画篇幅过多" class="headerlink" title="文字晦涩，环境和心理刻画篇幅过多"></a>文字晦涩，环境和心理刻画篇幅过多</h2><p>首先是感觉文字表述的方式非常不符合中国人的口味，过于啰嗦，典型的“翻译腔”。当然，中国人对于这种来自欧美的文学有这样的感受是很正常的，记得中学时候读福尔摩斯也是如此。</p>
<p>不过爱伦·坡作品的这种感受更强烈一些，除了不同语言带来的表述鸿沟之外，还要“怪罪”于他对<strong>环境氛围</strong>和<strong>心理活动</strong>的刻画实在过于细节，最终表现就是用了相当大的篇幅来做铺垫。最典型的莫过于《威廉·威尔逊》，在开始正式叙事之前竟然用了7页的内容做人物、心理和环境介绍，故事还未开始，恐怕心急的读者已经不耐烦了。</p>
<p>这对于先入为主地以侦探、推理小说的预期来阅读的我就会感到非常困惑，特别是在有噪音干扰的环境中，很难有心思能揣摩作者要表达的意境。这种困惑在几乎所有11篇故事中都有体现。</p>
<p>来看《红死魔的假面具》对室内环境氛围的一段表述：</p>
<p><font color=grey>“这里的玻璃窗是暗红色的——深暗的血液的颜色。这七间屋子里，没有一盏灯，也没有烛台，只有耀目的金器散布在各处，或者从天花板上垂吊下来。但在围绕着的回廊上，每一扇窗户对面都摆放着一只沉重的三角支架，三角支架上都放着一盆火，火光透过彩色玻璃，把房间照得通亮，于是就产生了大量奇形怪状、魑魅魍魉似的景象”</font></p>
<p>有没有惊悚的感觉？再来看《泄密的心》中对心理活动的一段表述：</p>
<p><font color=grey>“那个念头是如何钻进我的脑子的呢？现在已经很难说清这个问题了。可是，自从它钻入我的脑子，就日夜萦绕着我。那位老人对我十分友善，它一直以公允的态度对待我，也从未侮辱过我。对于他，我心存爱意，从没想过利用他，也没想过要伤害他，更不想得到他的钱财，”</font></p>
<p>是不是够婆婆妈妈？带着这种困惑我去查阅了爱伦·坡本人的经历以及身后评价，原来他的作品有两个特点：<u><strong>哥特风与心理刻画</strong></u>。</p>
<h3 id="哥特风"><a href="#哥特风" class="headerlink" title="哥特风"></a>哥特风</h3><p>哥特（<em>Goths</em>）原本是古代欧洲的一支民族，逐渐发展成了野蛮的代名词，与惊悚、恐怖、阴暗联系在了一起，在建筑等多种领域都有体现。文学上的哥特式必然要用一些文字来做阴森的氛围渲染。我想中国人对于哥特文化最熟悉的莫过于吸血鬼了，一些经典的吸血鬼影视作品，比如《黑夜传说》，画面格调一直都是灰暗的，故事的场景也是下水道、城堡等场景。</p>
<p>哥特的恐怖元素对于中国人来说，应该还是相对陌生的。我会觉得它确实很惊悚，但是仅仅是视觉上的，还远远达到不了直击心灵的效果。它表现出的恐怖往往是活人的无耻、粗鲁、暴力、阴郁、变态所带来的。而东亚文化中更恐怖的恐怕应该是像《山村老尸》、《咒怨》、《连体阴》等死人带来的复仇。后者则更能反映因果论，前者更现实，在因果关系上的表现则更需要发狂的活人来表达。</p>
<p>在我读的这一本书中，《红死魔的假面具》、《一桶蒙特亚白葡萄酒》、《厄舍府的倒塌》、《泄密的心》、《威廉·威尔逊》应该都是哥特元素足够丰富的恐怖小说。</p>
<p>《红死魔的假面具》讲了一个这样一个故事，在传染性的红死病流行期间，一位富人在庄园中大肆组织狂欢会，结果被“红死魔”团灭。故事非常简单，大量篇幅都在描述环境，比如每一间房子的奇幻装修风格，以及疯狂的聚会者如何作乐。对于“红死魔”，爱伦·坡用僵尸来描述他的肤色。这样一个猎奇的、恐怖的的场景就出现在我们面前。至于最后故事的戛然而止，作为叙事故事肯定是让人失望的，但要记住，这仅仅就是一部恐怖小说。</p>
<img src="/images/allan-poe/1.jpeg" width="200" />
<center><font color=grey size=1>《红死魔的假面具》插画，作者：Harry Clarke</font></center>

<p>《一桶蒙特亚白葡萄酒》简单来说就是一个人把他的“仇人”骗到地窖中困其致死的故事。显然，故事情节并不复杂，也不是重点，重点是爱伦·坡在篇幅中用大量的文字来描述了两方面内容：一是阴森的地窖环境，二是主人公的心理变化。中国人应该很难想象在自家房子的地下埋藏着先人遗骸这件事，不过西方应该并不陌生，英国王室成员就是集体埋葬在一座大教堂下面的。</p>
<img src="/images/allan-poe/2.jpeg" width="200" />
<center><font color=grey size=1>《一桶蒙特亚白葡萄酒》插画，作者：Harry Clarke</font></center>

<p>类似的情节在本书的《厄舍府的倒塌》一篇也有。它讲的故事是在阴暗的城堡内，主人公和城堡主人将其妹妹活埋的故事，城堡主人的阴郁给人留下了深刻印象。</p>
<img src="/images/allan-poe/3.jpeg" width="200" />
<center><font color=grey size=1>《厄舍府的倒塌》插画，作者：Harry Clarke</font></center>

<p>回到《一桶蒙特亚白葡萄酒》，爱伦·坡描述整个地窖的墙壁镶嵌着许多人类的遗骸，两位角色提着灯在里面走了很远，想想就足够惊悚。主人公一边骗对方喝酒，一边向前走，同时描述着主人公心理的所思所想，直到最后他疯狂地用砌墙的方式将对方封死在地窖内。网上看到一篇论文对此的描述是主人公借着复仇的名义发泄着自己的罪恶意念。从这里可以看到，爱伦·坡在恐怖小说中对人物心理的刻画是十分丰满的。</p>
<h3 id="心理刻画"><a href="#心理刻画" class="headerlink" title="心理刻画"></a>心理刻画</h3><p>事实上，这些小说中爱伦·坡对心理活动的描写所用的篇幅要远比对环境氛围的描写所用篇幅更大。</p>
<p>《黑猫》、《泄密的心》、《威廉·威尔逊》等都具有非常类似的、鲜明的心理刻画特征，甚至主人公开始表现出癫狂和多重人格的特质。</p>
<p>《黑猫》以第一人称的方式来讲述了主人公病态的心理变化。黑猫原本是主人公的一只温顺的宠物，主人公却因为心理的莫名变化，挖走了它的一只眼睛，最后把它给吊死了。主人公家里火灾过后，黑猫吊死的印记出现在了墙上，描绘出了一幅回魂复仇的画面。而后主人公又收养了一只来历不明的黑猫，却在第二天也丢失了一只眼睛，这给故事增加了相当大的魔幻氛围。最后主人公因为又想杀死这只猫，却失手杀死了妻子，为了避免东窗事发，他只好把尸体藏在了墙里面，在警察盘问时还能做到镇定自如。谁知那只黑猫也被意外地藏在了墙里面，它的叫声暴露了一切。</p>
<img src="/images/allan-poe/4.jpeg" width="200" />
<center><font color=grey size=1>《黑猫》插画，作者：Harry Clarke</font></center>

<p>《泄密的心》表现出的人物心理则更具不可理解。一位老人本没有任何过错，对待主人公也很好，仅仅是因为主人公不喜欢他的眼睛，就在深夜谋害了他，并把他藏在了屋子的地板下。结果等警察来询问时，主人公却发疯似的不打自招。读到这里可能会有莫名其妙的感受，但这正反应了人物扭曲、变态的心理。如果说需要一种熟悉的解释的话，那可能就是作恶终归过不了自己那一关。</p>
<img src="/images/allan-poe/5.jpeg" width="200" />
<center><font color=grey size=1>《泄密的心》插画，作者：Harry Clarke</font></center>

<p>《威廉·威尔逊》更上一层楼，讲来讲去甚至就只有主人公一位人物，他的所谓这位同名同姓同日生的同学，实际上就是他自己，不用读到最后就能猜得到。故事表达了这位主人公极具分裂的多重人格，杀死对方的同时，也将自己杀死。</p>
<img src="/images/allan-poe/6.jpeg" width="200" />
<center><font color=grey size=1>《威廉·威尔逊》插画，作者：Harry Clarke</font></center>

<p>如此复杂狂乱的心境描写，可能是爱伦·坡本人经历的影射。他自小没有父母陪伴，长大后又因玩忽职守被军队开除，后来妻子感染肺结核死去，他酗酒，在创作道路上的努力也都没有结果，这一些经历恐怕对于任何人都是一种恐怖的压抑。他会有挫败感吗？我们不得而知，有才是正常的。大胆猜测这样的经历已经影响了他的精神状态。</p>
<p>因此，把爱伦·坡简单地当作一位侦探、推理小说家，显然是过于片面了。事实上，他一生中的推理小说作品只有四、五部，但依然被认可为推理小说的鼻祖。我就从我阅读的几篇来感受一下爱伦·坡在推理小说上的开创性工作。</p>
<h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p>在本书中，《莫格街凶杀案》、《失窃的信》、《金甲虫》毫无疑问是最具推理特色的，情节节奏也更快，相对来说少了很多铺垫语言。而前两者更是引出了著名的侦探角色<em><strong>杜宾</strong></em>。从这一点上来说，<u>我猜测柯南·道尔的福尔摩斯和华生这一对搭档角色，灵感就来自于此，不知是否正确</u>。</p>
<p>《莫格街凶杀案》公认是世界上首部推理小说，并带来了推理情节的经典元素——密室。不过我阅读后觉得还是有两点可惜。</p>
<img src="/images/allan-poe/7.jpeg" width="200" />
<center><font color=grey size=1>《莫格街凶杀案》插画，作者：Harry Clarke</font></center>

<p>一是破案的关键点，即窗户的插销在之前并没有足够的铺垫，直接来到揭秘环节过于突兀。你没有给读者看，你怎么知道读者就没有能力发现呢？这也是侦探元素在书籍这种载体上的尴尬之处，如果有文字描述了，几乎相当于给你缩小了解谜的范围，如果不描述，就是上面这种突兀的感受。</p>
<p>二是铺垫了这样离奇的犯罪现场，最终案犯竟然是一只猩猩，大大降低了读者的感官刺激。相当于现在的发现了麦田怪圈，最后结果就是外星人搞的事情。我突然想起了10年前看过的美剧《迷失》，前期铺垫了大量未解之谜，最后圆不回去了，连时空穿越都搞出来了，类似的还有美剧《危机边缘》。</p>
<p>《失窃的信》中，侦探杜宾尝试完全从对方的角度来思考，是一大特色，并且得到的结论就是那封信就放在显而易见的位置，只不过按照常规思维根本不应该存在的位置，形象地描绘了一种<u>最危险的地方就是最安全的地方的画面</u>，用古话说，叫做<u>大隐隐于市</u>。不过虽然这篇小说广受赞誉，但是以现代人读取的感受来说，太过突兀和儿戏，第一是同样的问题，那封显而易见的信一开始并没有且也没办法给读者交代；第二是这位家族没落的杜宾先生，竟然能随意拜访大臣。不过这都不重要了，毕竟这部小说发表在将近200年前，以当时的文学环境来说，这样的一篇故事应该是相当吸引人的。</p>
<p>《金甲虫》是我认为的书中最具精彩的一个故事，我指的并非其中对密码的解谜（虽然我也认为在当时是相当新奇的了），而是其中对羊皮纸如何出现骷髅的解释。因为这张羊皮纸在前面已经有明显的交代，而且给出了二人在此的争议的画面。读者从这里很难能猜到是因为隐形墨水的原因，导致的后续威廉·勒格朗一系列怪异行为。</p>
<img src="/images/allan-poe/8.jpeg" width="200" />
<center><font color=grey size=1>《金甲虫》插画，作者：Harry Clarke</font></center>

<p>除此之外，我读的这本书中还有两篇故事，《瓶中手稿》和《乌鸦》，它们和《红死魔的假面具》共同导致了我的另一处困惑。</p>
<h2 id="故事情节架空，莫名其妙"><a href="#故事情节架空，莫名其妙" class="headerlink" title="故事情节架空，莫名其妙"></a>故事情节架空，莫名其妙</h2><p>从今天的视角很难理解爱伦·坡当时的创作意境。《红死魔的假面具》就是这样的一篇，一群人的狂欢会，怎么就有一个怪人突然杀了所有人。</p>
<p>不可否认地这篇小说有相当多的对人性的讽刺，但是红死病到底是什么呢，未免太多让人好奇。网上有资料说它指的是肺结核病或者霍乱，它们在当时都很常见。显然前者更可信一些：</p>
<ol>
<li>《红死魔的假面具》发表于1842年，这一年爱伦·坡的妻子开始感染肺结核，并在5年后去世；</li>
<li>肺结核是传染病，症状会发展为咳血</li>
</ol>
<p>爱伦·坡当时可能正是基于这样的担忧，才写出了这篇小说，可能也代表着一种宿命感。</p>
<p>所以说，<strong>历史人物的行为都不能离开当时的社会环境来空谈</strong>，抛开爱伦·坡的生平来阅读这篇小说，必然不能感同身受。</p>
<p>起码《红死魔的假面具》还能了解到其创作背景，但是《瓶中手稿》呢？这篇小说则是一篇来源于传说（<font color=grey size=1>幽灵船和地底空洞</font>）的魔幻创作，对于当时的读者来说，猎奇的感受更多一些，不过对于信息爆炸的今天，新鲜感骤减。不过还是那句话，要看历史环境，况且，这只是爱伦·坡为了参加比赛的投稿作品。</p>
<img src="/images/allan-poe/9.jpeg" width="200" />
<center><font color=grey size=1>《瓶中手稿》插画，作者：Harry Clarke</font></center>

<p>最后是《乌鸦》，这是最让我困惑甚至恼怒的一篇，完全不知道它在讲些什么，这样都能成为知名作品，恐怕要求也太低了。为此我不得不去查询这篇文章的背景资料——噢，原来这是一篇诗，爱伦·坡也是一位诗人。</p>
<p>这里我就不对诗加以评论了，毕竟我对现代诗嗤之以鼻，况且，翻译也失去了原作的韵味。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>毫无疑问，爱伦·坡是一位复杂的作家，虽然被称为推理小说的鼻祖，影响了柯南·道尔、江户川乱步、希区柯克等一系列大作家，但我们却不能以推理作家来称呼他。</p>
<p>他的作品在氛围风格和心理刻画上的表现，也许是他40年命途多舛生命中的流露。这一生中，他少年颠沛流离，中年亡妻、酗酒，在写作职业上的努力均付之东流。上面的这些作品，一篇最多为他带来几十美元的收入。在这样的逆境之下，《黑猫》、《泄密的心》、《威廉·威尔逊》中主人公的心理活动何尝不是爱伦·坡本人心境的反应。</p>
<p>我觉得他和梵高的境遇有一些类似，都是生前默默无闻，死后方才发现其才华。当然，梵高也是爱伦·坡的后辈，他出生时是1851年，而爱伦·坡死于1849年，以当时的卫生条件，加上他的不良习惯，这并不意外。</p>
<p>总之，以读故事的猎奇心态读爱伦·坡的作品，必然是一种浪费。你需要回到200年前那个时代，切身感受爱伦·坡的成长历程和际遇，才能读懂他的作品。</p>
<p><font color=grey size=1>（文中插画来自于wikiart.org）</font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/14/2023-01-14-how-sandbox-works/" class="post-title-link" itemprop="url">沙箱是如何工作的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-01-14 11:32:48 / 修改时间：12:08:38" itemprop="dateCreated datePublished" datetime="2023-01-14T11:32:48+08:00">2023-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">微前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>从 <em>qiankun</em> 开始，沙箱（或沙盒、sandbox）已经成了几乎所有微前端框架的标配功能。但事实上其内部涉及实现的大量细节，导致每家的能力参差不齐。</p>
<p>严格来说，沙箱并没有遵循的标准，在一些细节上的实现也没有对错，具体行为还是要取决于业务的需求。</p>
<p><em>Node.js</em> 的<a href="https://nodejs.org/dist/latest-v18.x/docs/api/vm.html" target="_blank">vm 模块</a>并不能直接移植到浏览器端，一个很大的原因在于浏览器涉及的视图（包括 DOM、URL）无法被拷贝，只能共享，那么共享到什么水平就成了沙箱方案能力差别的衡量标准之一。</p>
<h2 id="二、变量隔离"><a href="#二、变量隔离" class="headerlink" title="二、变量隔离"></a>二、变量隔离</h2><p>沙箱的基础能力就是隔离上下文，让下列操作都只局限在特定的上下文内，不会干扰到外部：</p>
<ul>
<li>删除已有变量，如 <em>delete obj.a</em> 或 <em>Relect.deleteProperty(obj, ‘a’)</em> ；</li>
<li>修改已有变量<ul>
<li>修改取值，如 <em>obj.a&#x3D;1</em> 或 <em>Reflect.set(obj, ‘a’, 1)</em> 或 <em>Reflect.defineProperty(obj, ‘a’, { value: 1 })</em></li>
<li>修改描述符，如 <em>Reflect.defineProperty(obj, ‘a’, { writable: false })</em></li>
<li>修改 frozen、sealed、extensible 状态，如 <em>Object.freeze(obj.a)</em> 、 <em>Object.seal(obj.a)</em> 或 <em>Object.preventExtensions(obj.a)</em></li>
<li>修改原型链，如 <em>Object.setPrototypeOf(obj.a, null)</em></li>
</ul>
</li>
<li>创建新的变量，如 <em>obj.a&#x3D;1</em> 或 <em>Relect.defineProperty(obj, ‘a’, {value: 1})</em></li>
</ul>
<p>上面的 <strong>obj</strong> 对象即指上下文对象，在浏览器中通常是 <em>window</em> 或 <em>document</em> ，这两个全局对象。但事实上，window 下的所有属性都可以直接取到，如 <em>addEventListener</em> 、 <em>name</em> 、 <em>CSS</em> 、 <em>location</em> 、 <em>history</em> 、 <em>navigator</em> 、 <em>HTMLElement</em> 等等，不胜枚举。因此， <strong>沙箱不可能监视所有变量的属性删除&#x2F;修改&#x2F;创建，因此也就不可能实现“完美”沙箱</strong> ，毕竟你不能遍历 window 下的所有属性，都监视一遍。</p>
<p><strong>with(){}</strong> 的做法不在考虑范围之内，对性能损耗过大。</p>
<p>这个事实带来的后果是，如果你想逃逸出沙箱，是非常容易的，比如 <em>navigator.no&#x3D;1</em> 。所以，沙箱在微前端中有使用价值的前提是， <strong>你必须尽可能保障对全局变量的访问是可控、无副作用的</strong> ，这是沙箱的脆弱之处，也是一种规范。接下来我们将在这一规范下继续讨论沙箱的实现问题，假设我们只考量对 window 和 document 这两个变量的属性监视。</p>
<h3 id="2-1-属性监视"><a href="#2-1-属性监视" class="headerlink" title="2.1 属性监视"></a>2.1 属性监视</h3><p>毫无疑问，在现代浏览器中，Proxy 是监视对象的最佳方案，通过它，我们应该可以被通知且控制获取、修改、删除、遍历等几乎所有操作。但是，proxy 对象真的可以为所欲为吗？</p>
<p>观察下列代码：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/yanni4night/xms2nkpa/15/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>这里涉及到了关于 <em>configurable</em> 导致的错误，事实上，有大量的操作都是被 proxy 所禁止的，在 <em>ECMA262</em> 上的<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>部分搜索 <strong>Invariants</strong> 能查询得到。因此 proxy 对象并非无所不能，它无法任意伪装原始对象的行为， <strong>该失败的必须失败</strong> 。相关规则包括如下：</p>
<table class="table">
    <thead>
        <th>对象操作</th>
        <th>不变量</th>
    </thead>
    <tbody>
        <tr>
            <td>defineProperty</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么使用defineProperty新增属性时不能返回true；</li>
                    <li>如果目标对象没有不可配置属性a，则代理对象也不能用defineProperty在将属性a定义成不可配置时时返回true；</li>
                    <li>如果目标对象没有不可配置且不可写的属性a，则代理对象也不能用defineProperty在将不可配置属性a定义成不可写时返回true</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>deleteProperty</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>get</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象在用get取值a时必须返回和目标对象相同值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少get的存取类型，那么代理在用get取值a时必须返回undefined</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getOwnPropertyDescriptor</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且没有有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时必须返回undefined；</li>
                    <li>除非目标对象有不可配置且不可写的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时就不能是不可配置且不可写的；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getPrototypeOf</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用getPrototypeOf时必须返回与在目标对象上调用的返回值</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>has</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用has获取a时不能返回false；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用has获取a时不能返回false；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>ownKeys</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用ownKeys时必须返回目标对象的全部属性名，不能包含额外属性名</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>set</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象就不能用set给a设置不同的值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少set的存取类型，那么代理在用set设值a时必须返回false</li>
                </ol>
            </td>
        </tr>
    </tbody>
</table>

<p>看似复杂，但实际总结来看，就是代理对象必须遵循一个原则： <strong>操作的结果要真实反应 target 的最新状态。</strong></p>
<p>举几个例子：</p>
<ul>
<li>如果Reflect.has(proxyObj, ‘a’)返回true，那么target就必须不能有一个不可配置的属性a；</li>
<li>如果Reflect.set(proxyObj, ‘a’, 1)返回true，那么target对象必然不能是不可扩展的，也不可以有一个不可写也不可配置的属性a</li>
</ul>
<p>如下的做法，直接代理原始 window、document 肯定是不可以的，根据上面的 Invariants 可知我们几乎必须把属性同步给原始的 window、document 才能不报错，显然违背我们做沙箱的初衷。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="variable language_">window</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>因此，通常的做法是把一个 <strong>新创建的对象</strong> 当作原始对象进行代理，下文简称为 <strong>target</strong> 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>所有的操作几乎都是最终体现在 target 对象上的，个别稍有例外。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">defineProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey, attributes: PropertyDescriptor</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="property">defineProperty</span>)(target, p, attributes);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deleteProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getOwnPropertyDescriptor</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="title class_">PropertyDescriptor</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">has</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params">target: T</span>): <span class="title class_">ArrayLike</span>&lt;<span class="built_in">string</span> | <span class="built_in">symbol</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey, value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getPrototypeOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">window</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但显然这样是有严重问题的，因为 target 是伪装的 Window 对象，它身上没有任何属性，这不但会影响 get、getOwnPropertyDescriptor、has、ownKeys 这些只读操作的结果，由于 Proxy 的规则，同样也会影响 defineProperty、deletePrperty、set 这些写操作的结果。</p>
<p>举个例子，本来真实 window 对象上有一个不可配置的属性 foo，正常来说，我们用 defineProxy 修改其描述符类型时一定会报错，但是 target 本身并没有任何属性，Reflect.defineProperty(target)却是成功的，不符合期望。</p>
<p>于是，业界常规的做法都是会把 <strong>原始对象的自身属性拷贝到 target 中，特别是那些不可配置的属性</strong> 。这样无论是读操作还是写操作，其结果都真实反应到了代码对象的 target 中，不会被任何 Proxy 原则所影响。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="variable language_">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> descriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, key);</span><br><span class="line">  <span class="keyword">if</span> (!descriptor.<span class="property">configurable</span>) <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, p, descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步的成本稍高，但是又是必须的。在具体的实现策略上也可以区分为一次性拷贝和懒惰式拷贝，即用到某属性时才执行拷贝。</p>
<h3 id="2-2-主动变量逃逸"><a href="#2-2-主动变量逃逸" class="headerlink" title="2.2 主动变量逃逸"></a>2.2 主动变量逃逸</h3><p>虽然沙箱的关键作用就是为了限制变量的访问和变更范围，但是毕竟在同一个浏览器页面之下，难免有需要例外放行的 case。我们称这类变量为 exception 或者 escaped，这种功能称之为“主动变量逃逸”。</p>
<p>实现主动变量逃逸比较简单，以 set 和 get 操作为例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不过别忘记了 Proxy 的那些 Invariants 限制，上述这些操作的结果都要反应到 target 身上，所以最后还是得把原始对象（如 window）上的属性同步到 target 上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-函数属性上下文"><a href="#2-3-函数属性上下文" class="headerlink" title="2.3 函数属性上下文"></a>2.3 函数属性上下文</h3><p>上面提到，我们需要把原始对象（window、document）的属性同步到 target 对象中，Proxy 才会不受到 Invariants 的影响，能更真实的模拟读写操作。</p>
<p>我们看下面一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/nhtwo0x2/4/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>再来看这样一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/1buvLtag/2/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>有这样一类函数，它们只能在指定的上下文中执行，即便是 Proxy 也不可以，否则在 Chrome 下就会报告 <strong>Illegal invocation</strong> 错误。在 Firefox 和 Safari 上的错误信息会更通俗易懂一些。</p>
<p>目标没有很好的办法来解决这个问题，毕竟函数内部的逻辑是无法预测的，只能尽可能兼容。一些策略有：</p>
<ul>
<li>如果属性名是 constructor，无需特殊处理；</li>
<li>如果属性名以大些字母开头， <strong>认为它们是构造函数</strong> ，无需特殊处理；</li>
<li>创建包装函数来锁定上下文:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newValueInTarget = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">unknown</span>[]</span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="comment">// 小写字母也可能是构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(valueInRaw, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(valueInRaw, raw, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一些特殊属性的处理，例如 window 上的 eval、isFinite、isNaN、parseFloat、parseInt、hasOwnProperty、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent，直接走主动变量逃生即可</li>
</ul>
<h2 id="三、执行-JavaScript-代码"><a href="#三、执行-JavaScript-代码" class="headerlink" title="三、执行 JavaScript 代码"></a>三、执行 JavaScript 代码</h2><p>上面讨论的是沙箱的最关键能力——变量隔离，但无论实现怎样的能力，子应用的 JS 代码还是要得到执行，那么该如何执行的？</p>
<h3 id="3-1-eval"><a href="#3-1-eval" class="headerlink" title="3.1 eval"></a>3.1 eval</h3><p>业界普遍的做法是异步 fetch 到源代码，然后 eval 它，虽然需要跨域环境的支持，但并不是难事。只是 eval 需要一些技巧。</p>
<p>首先，eval 需要在真正的 window 上下文中执行，避免调用环境的影响，这一点，目前已经有比较明确的实现方案，就是“间接调用”：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evalScript</span>(<span class="params">code: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span>, <span class="built_in">eval</span>)(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，利用函数入参来改变一些全局变量名的作用域，将其指向既定的对象，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, self, parent, top, globalThis, document) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.window, winProxy.self, winProxy.parent, winProxy.top, winProxy.globalThis, winProxy.document)`</span>);</span><br></pre></td></tr></table></figure>

<p>从这里也能看出，如果直接引用如 location、navigator、history 将无法被沙箱捕获，你需要用 window.location、window.navigator、window.history 的方法。进而可以推断出你在全局定义的变量，也必须以 window 属性的方式来读取，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span> <span class="attr">entry</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>像上面这种 case，如果不以 window.loadStartTime 的方式能不能读取得到呢？也有一些技巧可做到。</p>
<p>比如使用嵌套递归作用域的方式来实现，相当于每执行一次 JS 之后，就会为下一次执行生成一个新的嵌套上下文，这样后面的 JS 就可以直接读取上次的变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现机理稍有复杂，理论上也会带来额外的性能开销，而且对于下面这种双向访问的场景也无法支持：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendLog</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 访问未预定义变量</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">sendToServer</span>(&#123; loadCost &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过仍然具有一定的价值，对于以 HTML 作为 entry 的子应用的容纳范围更广，子应用的灵活度更高。</p>
<h3 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h3><p>有时，需要暴露给子应用的 JS 一些临时的虚拟变量，比如 qiankun 提供的 _<strong>_POWERED_BY_QIANKUN__</strong> ，而且允许不同子应用读取到的同一名称的变量有不同的取值。</p>
<p>如果不开启沙箱的话，这一功能反而困难，需要在 window 上定义变量，然后以同步的形式运行子应用 JS 代码，最后在从 window 上移除掉。这个过程不但很可能和 window 上已经有的同名变量冲突，而且也只能保证同步代码中能读取到，异步代码中就读不到。举例说明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在沙箱环境中，实现环境变量更简单，而且可以不受同步&#x2F;异步的影响，可以持续访问。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, document, __IN_MICRO_ENV__) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.document, winProxy.__IN_MICRO_ENV__)`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-ESM"><a href="#3-3-ESM" class="headerlink" title="3.3 ESM"></a>3.3 ESM</h3><p><strong>ESM</strong> 格式的 JS 代码不能直接 eval 来执行。事实上，浏览器还未提供能直接运行 ESM 源码的方法。Garfish 采取来将源码转换成 URI 的方式实现了一定程度的 eval 能力，但是需要正则匹配 import 指令，存在一定的隐患。即便如此，因为不能用函数直接封装 ESM 源码，因此也无法实现沙箱运行。因此，garfish 还实现了一套运行时转译 ESM 的机制，但是对性能有较大影响，相信其稳定性也存在安全隐患。</p>
<h2 id="四、DOM-结构"><a href="#四、DOM-结构" class="headerlink" title="四、DOM 结构"></a>四、DOM 结构</h2><p>一般来说，子应用有自认为的 DOM 环境，比如 html、body、head 以及#app 等等。</p>
<h3 id="4-1-固定-DOM"><a href="#4-1-固定-DOM" class="headerlink" title="4.1 固定 DOM"></a>4.1 固定 DOM</h3><p>在沙箱环境中，如果把真正的 html、body、head 暴露给子应用，那么它很有可能在上面做一些副作用的操作，比如插入新 DOM、修改样式等等。为了避免这种情况，微前端框架一般都会给子应用生成一个模拟的 DOM 结构，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pseudo-html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pseudo-title</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-body</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pseudo-html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DOM API 中的 <strong>document.documentElement</strong> 、 <strong>document.body</strong> 、 <strong>document.head</strong> 也都指向它们。</p>
<p>根据业务需求，可以做更深的伪装定制，通过以下测试：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">tagName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">nodeName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">version</span> === <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentNode</span> === <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentElement</span> === <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHtmlElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHtmlElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">tagName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">nodeName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">constructor</span> === <span class="title class_">HTMLBodyElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLBodyElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">tagName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">nodeName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHeadElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHeadElement</span> === <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>注意 <strong>document.documentElement.parentElement</strong> ，如果等于 null，可能对一些视觉框架、组件库等需要用 parentElement 向上递归搜索的功能不友好。可根据需要是否开启以上伪装能力。</p>
<h3 id="4-2-存量-DOM"><a href="#4-2-存量-DOM" class="headerlink" title="4.2 存量 DOM"></a>4.2 存量 DOM</h3><p>存量 DOM 是指那些在子应用的 HTML entry 中已有的 DOM 结构，简单的如#app，也可能有更复杂的结构。</p>
<p>通常需要把它们同步到上述固定 DOM 的 body 中，也有些方案把 head 中的 meta 都同步了过来。</p>
<p>一旦需要拷贝，需要考虑如下问题：</p>
<ul>
<li>非法元素、样式的过滤；</li>
<li>元素在沙箱环境的适配</li>
</ul>
<h3 id="4-3-新增-DOM"><a href="#4-3-新增-DOM" class="headerlink" title="4.3 新增 DOM"></a>4.3 新增 DOM</h3><p>新增 DOM 有多种创建方式：</p>
<ul>
<li>document.createElement()；</li>
<li>dom.clone()；</li>
<li>dom.innerHTML&#x3D;</li>
</ul>
<p>通常来说只有第一种会被沙箱接管，使得新创建的 DOM 的 ownerDocument、baseURI 是符合沙箱环境的。</p>
<p>需要特别关注的是，新创建的 script 元素会被转换成一个无实际功能的&lt;pseudo-script&gt;元素。框架会在后台自行下载&#x2F;执行其代码，模拟了 script 的能力。</p>
<p>Custom Element默认是inline类型，除了在shadow DOM内部使用 <strong>:host{display:block}</strong> 外，只能在外部用选择器覆盖。未来如果Safari支持<a href="https://caniuse.com/custom-elementsv1" target="_blank">继承built-in元素</a>后可以解决。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>沙箱只能处理有限范围内的变量隔离，通常为 window 和 document；</li>
<li>以 eval function 的方式执行 JS 源码，全局变量引用应以 window 属性的方式使用；ESM 无法支持沙箱；</li>
<li>子应用的 DOM 结构可以被伪装，但仍然能轻易实现逃逸</li>
</ul>
<p><strong>沙箱的本质是为子应用打造一个微型的独立浏览器环境，受限于成本，无法做到尽善尽美，仍然需要子应用遵循一定的规范和约定</strong> 。而由于微前端的主、子应用在管理上的独立性，往往沙箱能力的升级会对子应用造成较大的影响。</p>
<h2 id="六、未来发展"><a href="#六、未来发展" class="headerlink" title="六、未来发展"></a>六、未来发展</h2><p>业界对沙箱的实现均强依赖 Proxy 技术，区别仅在于对副作用的拦截能力多少。随着业务复杂度的提升，以及一些存量旧业务在遵循冲突约定的改造成本上的考虑，逐渐意识到 Proxy 的能力仍然有限，想实现健壮性更强的沙箱环境，开发成本高且性能不稳定。</p>
<p>业界已经有一些方案开始逐渐回归 iframe。iframe 天生具有强隔离性，不必对全局变量一一关注即可达到期望的隔离性能。不过这种一刀切的做法在实际的业务中仍然受到挑战，比如对主动逃逸变量的支持，比如对 DOM 的操作等等，仍然需要一定的机制将 iframe 和主页面整合到一起。这一步，仍然离不开 Proxy 的支持。</p>
<p>ECMA 已经有一个新的提案，叫做<a href="https://github.com/tc39/proposal-shadowrealm" target="_blank">ShadowRealm</a>，位于 Stage3，对于创建独立的 JS 执行环境是一个比较理想的方案。不过微前端离不开视图，如何共享视图对象以及控制共享的粒度，就不是 ShadowRealm 的范围了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/" class="post-title-link" itemprop="url">《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-20 15:26:55" itemprop="dateCreated datePublished" datetime="2022-04-20T15:26:55+08:00">2022-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-14 11:28:13" itemprop="dateModified" datetime="2023-01-14T11:28:13+08:00">2023-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%92%A8%E8%AF%A2%E7%9A%84%E5%A5%A5%E7%A7%98/" itemprop="url" rel="index"><span itemprop="name">咨询的奥秘</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="没坏的话就不要修"><a href="#没坏的话就不要修" class="headerlink" title="没坏的话就不要修"></a>没坏的话就不要修</h2><p>这里讲的系统应该能够治愈。不过在现实场景中不太可能，即使可能在时效性上也不允许。</p>
<p>如果这里我们把这句话理解成：<strong>不要瞎折腾，没事找事</strong>，显然有一种消极的态度，如果一直安于现状，就会阻断创新。</p>
<p>从咨询师的角度来看更容易理解这句话，咨询师是系统的“外来物”，不是对于系统出现的所有问题都要横加干涉，适当的放任反而有益于系统的成长。可以借着下一句话来深入理解：</p>
<h2 id="反复治疗一个可以治愈的系统最终让它不能治愈"><a href="#反复治疗一个可以治愈的系统最终让它不能治愈" class="headerlink" title="反复治疗一个可以治愈的系统最终让它不能治愈"></a>反复治疗一个可以治愈的系统最终让它不能治愈</h2><p>引用书中的一句话就能轻松解释：</p>
<blockquote>
<p>那些孩子四岁多了还帮忙擦鼻子的父母，以及靠为同一个客户反复解决同一个问题混饭吃的顾问，都应该牢记这个秘密。</p>
</blockquote>
<p>那是那句话，不是都有问题都要横加干涉。否则最终会超出自己的能力范畴。</p>
<h2 id="每个处方都包含两部分：药品和正确使用它的方法"><a href="#每个处方都包含两部分：药品和正确使用它的方法" class="headerlink" title="每个处方都包含两部分：药品和正确使用它的方法"></a>每个处方都包含两部分：药品和正确使用它的方法</h2><p>我能把它理解成：“文档很重要，是产品的一部分”么？</p>
<p>我们在提供服务的时候，除了服务实体本身之外，还需提供使用说明。某些领域会提到以代码自注释能力来衡量代码的优劣，我觉得有一定道理但不是全部。</p>
<p>简单的系统确实可以做到轻松上手的目的，但也仅限于简单的系统。</p>
<h2 id="如果已经做过的事情没能解决问题，就告诉他们做点别的"><a href="#如果已经做过的事情没能解决问题，就告诉他们做点别的" class="headerlink" title="如果已经做过的事情没能解决问题，就告诉他们做点别的"></a>如果已经做过的事情没能解决问题，就告诉他们做点别的</h2><p>好打浑的说辞，不过确实有效。系统的某些问题往往出乎所有人意外，如果不能亲身实地地验证，仅仅依赖现有经验的人脑逻辑推断，确实不一定能够做出最终的诊断。</p>
<p>所以，在走投无路的时候，要学会接纳那些看似绝对无效的方案，说不定有意外的收获。</p>
<h2 id="务必让他们付给你足够多的钱，这样他们才会照你说的去做"><a href="#务必让他们付给你足够多的钱，这样他们才会照你说的去做" class="headerlink" title="务必让他们付给你足够多的钱，这样他们才会照你说的去做"></a>务必让他们付给你足够多的钱，这样他们才会照你说的去做</h2><p>就像练习书法用廉价的草纸会比用昂贵的字帖更不容易练好一样，只有你付出的成本更高，你才会更加专注和认真，因为失败的损失更大。</p>
<p>有另一种基于责任归属的解释，如果用字帖还练不好书法，那么将无法将责任落在纸的种类身上。</p>
<p>因此，通过提高任务的成本和消耗，将更有可能让执行脉络贴近自己的设计。</p>
<h2 id="来得早不如来得巧"><a href="#来得早不如来得巧" class="headerlink" title="来得早不如来得巧"></a>来得早不如来得巧</h2><p>时机很重要。</p>
<h2 id="【伯登法则】要是你不能改掉缺点，就把它变成特点"><a href="#【伯登法则】要是你不能改掉缺点，就把它变成特点" class="headerlink" title="【伯登法则】要是你不能改掉缺点，就把它变成特点"></a>【伯登法则】要是你不能改掉缺点，就把它变成特点</h2><p>这一法则将适用很多行业黑话，比如公司提供晚餐意味着加班更多。产品的特性从不同的视角可能会有截然相反的描述，核心原则就是避重就轻。这不一定就是一种欺骗，因为很可能那些未提及的缺陷对客户压根没有影响，或者打一个时间差，等客户发现了的时候，缺陷已经被修复，如果是可能甚至还可以是付费升级。</p>
<h2 id="【镀金法则】要是没法当成特点来宣扬，那就冒充一下"><a href="#【镀金法则】要是没法当成特点来宣扬，那就冒充一下" class="headerlink" title="【镀金法则】要是没法当成特点来宣扬，那就冒充一下"></a>【镀金法则】要是没法当成特点来宣扬，那就冒充一下</h2><p>这是“扒瞎”的意思吗？也许有作用，只要没人拆台和较真。对于聚集了大量耿直的人的行业中，可能风险性较大。</p>
<p>如果仅仅是电视广告在那里“镀金”的话，相信很少有人会真的打电话投诉；如果在一个小型的会议现场胡说八道，我想大概率会被“怼”。</p>
<p>这种缺乏货真价实干货的纯语言技巧，肯定不能撑太久。因此才会有下一句：</p>
<h2 id="所有镀金的东西都得改正"><a href="#所有镀金的东西都得改正" class="headerlink" title="所有镀金的东西都得改正"></a>所有镀金的东西都得改正</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/09/21/2018-09-21-prettier-eslint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/21/2018-09-21-prettier-eslint/" class="post-title-link" itemprop="url">prettier配合eslint执行自动化代码格式化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-21 17:24:25" itemprop="dateCreated datePublished" datetime="2018-09-21T17:24:25+08:00">2018-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://eslint.org/">eslint</a> 早已取代 <a target="_blank" rel="noopener" href="https://www.jslint.com/">jslint</a> 成为了 JavaScript 标准的风格检查工具，提供了大量规则（rule）。这些规则部分是可以支持 <em>fixable</em> 的，也就是说可以自动修复代码。但是现在来看，eslint 提供的修复功能还是太弱。因此 Facebook 开发了 <a target="_blank" rel="noopener" href="https://prettier.io/">prettier</a>，一个专门司职代码格式化的工具，它不仅仅支持 JavaScript 语法，甚至还支持 Markdown。因此，把它们配合起来是一种自然而然的想法，首先我们有一个 eslint-config 定义，我们希望经过 format 之后的代码能100%通过 lint 校验。我们也希望在 git hook 中能自动 format 代码。</p>
<p>在实际应用中，让 prettier 完美配合 eslint 并不容易。根本原因在于 prettier 格式化代码的一些行为是不可配置的，而这些配置极有可能与 eslint 配置是冲突的。</p>
<p>例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span> || b === <span class="number">2</span> || c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 eslint 中，我们经常配置在折行时把符号写在前边：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span></span><br><span class="line">|| b === <span class="number">2</span></span><br><span class="line">|| c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但 prettier 则强行写在后面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="number">1</span> ||</span><br><span class="line">b === <span class="number">2</span> ||</span><br><span class="line">c ===<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>prettier 提供了与 eslint 配合使用的<a target="_blank" rel="noopener" href="https://prettier.io/docs/en/eslint.html">官方方法</a>。但这种方式的本质是使用 eslint-config-prettier 来抹平 prettier 与 eslint 之间不可调和的冲突。一旦我们定义的私有 eslint-config 与 eslint-config-prettier 有影响格式化结果的冲突，那么 lint 必然失败。不过这种方式的一大好处是仅仅对接 eslint 就能完成 lint 与 fix 的操作，集成性很强。</p>
<p>理解这种现象很容易，eslint 的 rules 是没有顺序的，因此在 fix 阶段，极有可能 prettier 的 rule 执行在最后阶段，结果显然与我们定义的最终 eslint 配置是冲突的。</p>
<hr>
<p>相比于引用一系列 eslint-config，并维护它们的顺序，我们索性只维护我们自己的一份 eslint-config，反而更清晰。有这一份配置来执行 fix，产出一定可以通过lint。</p>
<p>但我们肯定不想直接抛弃 prettier，那么就把它的执行放在最前面，让它的产出再通过 eslint 即可。</p>
<p>已经存在这种现成的解决方案，就是 <a target="_blank" rel="noopener" href="https://github.com/prettier/prettier-eslint">prettier-eslint</a>。虽然看起来比较畸形，但可能是唯一一种比较能用且清晰的方案了。</p>
<p>但也有缺点，一旦将来某些 prettier 的不可配置的行为也不能被 eslint 所 fix，工作流就 gg 了。整合的过程就是这样，本来是相互分离的两个系统，让它们一起工作，总要失去点什么。</p>
<blockquote>
<p>Code ➡️ prettier ➡️ eslint –fix ➡️ Formatted Code ✨</p>
</blockquote>
<p>Q：如果能保证 prettier 提供的 rule 能先行执行呢？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/03/23/2018-03-23-principle-+/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/23/2018-03-23-principle-+/" class="post-title-link" itemprop="url">Javascript '+' 运算符原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-23 15:02:57" itemprop="dateCreated datePublished" datetime="2018-03-23T15:02:57+08:00">2018-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>继了解完“&#x3D;&#x3D;”的原理后，再来了解一下加号“+”的 ECMAScript 实现原理。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure>

<p>第一步，对 a 和 b 执行 *toPrimitive()*，不指定 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-ordinarytoprimitive">hint</a>。</p>
<p>以 <em>toPrimitive(a)</em> 为例，先看 a 有没有定义 <em>Symbol.toPrimitive</em>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = customToPrimitive;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customToPrimitive</span>(<span class="params">hint</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">            ...</span><br><span class="line">        <span class="attr">default</span>: <span class="comment">// &#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果定义了 <em>Symbol.toPrimitive</em> 属性，则执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customToPrimitive.<span class="title function_">call</span>(a, <span class="string">&#x27;default&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>否则执行原生 *toPrimitive(“number”)*，也就是要依次调用 a 的 <em>valueOf</em> 和 <em>toString</em> 方法。</p>
<p>如果执行 <em>a.valueOf()</em> 返回不是 Object，则为 <em>toPrimitive(a)</em> 的终值，否则执行 *a.toString()*。</p>
<p>接下来，看 a 有没有定义 toString，如果有，则执行 *a.toString()*，为 <em>toPrimitive(a)</em> 的终值。</p>
<p>如果没有，则执行原型链顶端的 <em>Object.prototype.toString</em>,这首先要看 a 有没有定义 <em>Symbol.toStringTag</em>。</p>
<p>如果定义了，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">customStringTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: customStringTag</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么返回 *”[object “ + customStringTag.apply(a) + “]”*，否则返回 *”[object Object]”*，为 <em>toPrimitive(a)</em> 的终值。</p>
<p>如果发现 <em>toPrimitive(a)</em> 或者 <em>toPrimitive(b)</em> 任一为字符串，则执行字符串拼接，否则执行数字加法，即 *toNumber(a) + toNumber(b)*，这也能解释 <strong>true + true &#x3D; 2</strong> 的问题。</p>
<hr>
<p>可见 <em>a + b</em> 核心就是 <em>toPrimitive</em> 操作，只不过从 ES2015 以来，<em>toPrimitive</em> 受到 Symbol 的影响，变得越来越复杂。</p>
<p>相比之下，减号“-”就很简单了，就是执行 *toNumber(a) - toNumber(b)*。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/27/2018-02-27-cultivating-a-paradoxical-frame-of-mind/" class="post-title-link" itemprop="url">《咨询的奥秘》 第二章 培养矛盾的思维框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-27 16:43:11" itemprop="dateCreated datePublished" datetime="2018-02-27T16:43:11+08:00">2018-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-14 11:28:13" itemprop="dateModified" datetime="2023-01-14T11:28:13+08:00">2023-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%92%A8%E8%AF%A2%E7%9A%84%E5%A5%A5%E7%A7%98/" itemprop="url" rel="index"><span itemprop="name">咨询的奥秘</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于社会主义的中国人来讲，经过初中、高中、大学的思想政治课的洗礼，理解矛盾并非难事，我们辩证唯物主义的内容要更丰富得多。</p>
<h1 id="第二章-培养矛盾的思维框架"><a href="#第二章-培养矛盾的思维框架" class="headerlink" title="第二章 培养矛盾的思维框架"></a>第二章 培养矛盾的思维框架</h1><h2 id="不要理性，要合理"><a href="#不要理性，要合理" class="headerlink" title="不要理性，要合理"></a>不要理性，要合理</h2><p>这两个相似的词忽然让我很难揣摩这句只包含6个字的话。什么样的事情是合理但不理性的呢？我理解，理性是对事件真实客观的描述，是能用逻辑严格证明的，往往获取“理性”需要很大的成本，甚至在有意义的时间内无法获取；而合理则是一种模棱两可的适当妥协，在有些事情无法获取“理性”之时，委曲求全的权宜之计都可能是一种合理。合理是一种“反牛角尖的”行为，似乎更倾向于“糊弄”。</p>
<p>在作者涉猎的软件咨询行业，很难想象不求甚解的方案也能行得通。从技术上来讲，确实再隐晦的故障都是可以绝对定位的，但对于项目来说，往往最初的设计和真正的落地会有很大差距，如果没有绝对的经验积累，那么项目在循循渐进的过程中往往都会带着猜的成份。换句话说，没有理性，只要比上一版本又说改进，即为合理。从这角度上来说，一味得追求最佳既是不可能的任务，也不能称之为理性的抉择，毕竟世界是个矛盾体，在矛盾中寻求理性的过程收获利益，才是上上之选。</p>
<p>从这里可以衍生出一种经典的产品进化模型，比如想造一辆汽车，下面有两种方案：</p>
<ol>
<li>第一种，先造轮子、发动机、车架，最终拼接成完善的汽车；</li>
<li>第二种，先造一辆自行车、摩托车、三轮车，最后一辆汽车</li>
</ol>
<p>第二种方案看似费时费力，往往更容易被人接受，也更容易实现。</p>
<h2 id="自以为无所不知的人最容易上当"><a href="#自以为无所不知的人最容易上当" class="headerlink" title="自以为无所不知的人最容易上当"></a>自以为无所不知的人最容易上当</h2><p>过于自信就是自负，往往容易对客观事实视而不见。这和“撞车的都是老司机”、“淹死的都是会水的”是类似的道理。</p>
<h2 id="生活太重要，所以不能太较真"><a href="#生活太重要，所以不能太较真" class="headerlink" title="生活太重要，所以不能太较真"></a>生活太重要，所以不能太较真</h2><p>这论题太大了，似乎已经上升到了哲学和三观的高度上来了。我想作者要表达的意思应该是，对于无法解释的事物不必过于在意，毕竟你的无知正是矛盾世界里的必不可少的成份。</p>
<h2 id="不付出就什么也得不到"><a href="#不付出就什么也得不到" class="headerlink" title="不付出就什么也得不到"></a>不付出就什么也得不到</h2><p>正是矛盾的合理体现，要想得到什么，不可避免地要失去什么，当然，反过来不一定成立，往往都不成立。</p>
<h2 id="提升一方面，就要牺牲另一方面"><a href="#提升一方面，就要牺牲另一方面" class="headerlink" title="提升一方面，就要牺牲另一方面"></a>提升一方面，就要牺牲另一方面</h2><p>同上</p>
<h2 id="费舍基本定理——你越适应现状，就越难适应变化"><a href="#费舍基本定理——你越适应现状，就越难适应变化" class="headerlink" title="费舍基本定理——你越适应现状，就越难适应变化"></a>费舍基本定理——你越适应现状，就越难适应变化</h2><p>显然，与现有系统耦合越大，与其它系统兼容越小。抽象与具象。</p>
<blockquote>
<p>伴随着年纪的增长，我觉得自己就越来越难以适应变化。</p>
</blockquote>
<h2 id="顾问一般在解决你提出的第三个问题时最有成效"><a href="#顾问一般在解决你提出的第三个问题时最有成效" class="headerlink" title="顾问一般在解决你提出的第三个问题时最有成效"></a>顾问一般在解决你提出的第三个问题时最有成效</h2><p>这也解释了为什么人在20多岁的时候最富创造性，因为年老后才更“善于”和这个“平庸”的世界打交道。</p>
<p>始终关注自己在什么时候拥有最高效的进步，在合适的时候，应当勇于舍弃舒适的温床。</p>
<blockquote>
<p>我确实应该换个工作了🍟</p>
</blockquote>
<h2 id="我们能做，这是所需的费用"><a href="#我们能做，这是所需的费用" class="headerlink" title="我们能做，这是所需的费用"></a>我们能做，这是所需的费用</h2><p>没有成本的改变是不现实的，懂得这个道理，避免在愚蠢的任务上浪费时间与口舌。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/02/19/2018-02-19-pagex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/19/2018-02-19-pagex/" class="post-title-link" itemprop="url">获取元素在文档流中的位置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-19 18:00:15" itemprop="dateCreated datePublished" datetime="2018-02-19T18:00:15+08:00">2018-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>元素在文档流中的位置应与页面滚动量无关，指的是该元素左上角（包括border，但不包括margin）距离整个页面左上角的水平和垂直位置。</p>
<p>获取此位置有两种方法，观察 <a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/blob/2.2-stable/src/offset.js#L101">jQuery 2.2 源码</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = elem.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="keyword">var</span> win = elem.<span class="property">ownerDocument</span>.<span class="property">defaultView</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">top</span>: rect.<span class="property">top</span> + win.<span class="property">pageYOffset</span>,</span><br><span class="line">    <span class="attr">left</span>: rect.<span class="property">left</span> + win.<span class="property">pageXOffset</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>getBoundingClientRect</code> 是一个十分高效的方法，用来获取元素相对于可见的视口的位置，而这个位置是与滚动量有关的，只有这个位置加上滚动量，即是与文档左上角的距离。</p>
<p>如果 <code>getBoundingClientRect</code> 不存在，我们依然可以通过遍历计算出结果。首先需要了解 DOM 元素的几个属性：</p>
<ol>
<li>offsetParent 向上祖先中第一个定位元素；</li>
<li>offsetLeft 距离 offsetParent 左边界的水平位置，与滚动量无关</li>
<li>offsetTop 距离 offsetParent 上边界的垂直位置，与滚动量无关</li>
<li>clientLeft 一般为左边框宽度</li>
<li>clientTop 一般为上边框宽度</li>
<li>scrollLeft 水平滚动距离</li>
<li>scrollTop 垂直滚动距离</li>
</ol>
<p>因为我们要得到的距离是当时的绝对距离，与该元素的各个祖先元素的滚动量是有关的，因此我们不能简单地通过加和 <em>offsetLeft</em> 与 <em>offsetTop</em> 来得到最后的值，必须减去每一级祖先的滚动量。</p>
<p>具体逻辑大概就是，向该元素的上面遍历，减去每个元素的滚动量，一旦遇到是 <em>offsetParent</em>，则加上 <em>offsetLeft</em> 与 <em>offsetTop</em>。具体可参考 <a target="_blank" rel="noopener" href="https://github.com/jquery/jquery/blob/1.4.4/src/offset.js#L79">jQuery 1.4.4 源码</a>。简单来讲就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">offset</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> top = ele.<span class="property">offsetTop</span>;</span><br><span class="line">    <span class="keyword">var</span> left = ele.<span class="property">offsetLeft</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> offsetParent = ele.<span class="property">offsetParent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ele = ele.<span class="property">parentNode</span>) &amp;&amp; ele !== <span class="variable language_">document</span>) &#123;</span><br><span class="line">        left -= (ele.<span class="property">scrollLeft</span>);</span><br><span class="line">        top -= (ele.<span class="property">scrollTop</span>);</span><br><span class="line">        <span class="keyword">if</span> (offsetParent === ele) &#123;</span><br><span class="line">            top += ele.<span class="property">offsetTop</span> + ele.<span class="property">clientTop</span>;</span><br><span class="line">            left += ele.<span class="property">offsetLeft</span> + ele.<span class="property">clientLeft</span>;</span><br><span class="line">            offsetParent = offsetParent.<span class="property">offsetParent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;top,left&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然 clientTop 与 clientLeft 并非永远代表的是上边框和左边框的宽度。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/02/12/2018-02-12-vue-dom-diff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/12/2018-02-12-vue-dom-diff/" class="post-title-link" itemprop="url">Vue.js 中的 DOM Diff 算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-12 14:41:01" itemprop="dateCreated datePublished" datetime="2018-02-12T14:41:01+08:00">2018-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇我们熟悉了一下 <em>Inferno.js</em> 的 DOM Diff 算法。今天我们来看 <a target="_blank" rel="noopener" href="https://vuejs.org/">Vue.js</a> 框架的 DOM Diff 算法。</p>
<p><em>Vue.js</em> 的作者没有编写自己的算法，而是使用了 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">Snabbdom</a>，并做了适当的修改。</p>
<p>DOM Diff 的关键算法在 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom/blob/v0.7.1/src/snabbdom.ts#L179">https://github.com/snabbdom/snabbdom/blob/v0.7.1/src/snabbdom.ts#L179</a>。</p>
<p>同样，我们依然假设有原始的 DOM 集合A为 “<em>dfibge</em>”，更新后的集合B为 “<em>igfheb</em>”。</p>
<p>创建4个指针 <em>oldStartIdx</em>、<em>oldEndIdx</em>、<em>newStartIdx</em>、<em>newEndIdx</em>，初始分别指向A的起始点、结束点和B的起始点、结束点。显然：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oldStartIdx=<span class="number">0</span></span><br><span class="line">oldEndIdx=<span class="number">5</span></span><br><span class="line">newStartIdx=<span class="number">0</span></span><br><span class="line">newEndIdx=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>第一步，比较 A[oldStartIdx] 和 B[newStartIdx]，如果相同，则 oldStartIdx++、newStartIdx++。<br>第二步，比较 A[oldEndIdx] 和 B[newEndIdx]，如果相同，则 oldEndIdx++、newEndIdx++。</p>
<p>在本例中，以上两步全部不满足，跳过。</p>
<p>第三步，比较 A[oldStartVnode] 和 B[newEndVnode]，如果相同，则节点发生了右移。<br>第四步，比较 A[oldEndIdx] 和 B[newStartIdx]，如果相同，则节点发生了左移。</p>
<p>在本例中，以上两步全部不满足，跳过。</p>
<p>第五步，在A中搜索 B[newStartIdx]，即 <em>i</em>，找到则把A中的 <em>i</em> 移到 A[oldStartVnode] 前面并 newStartIdx++、oldStartVnode++，否则则创建它。</p>
<p>在本例中，A变成 <em>idfbge</em>。</p>
<p>返回第一步。</p>
<hr>
<p>可以看到这个算法类似于优化后的插入排序。按照此算法，A的变换路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">A:dfibge</span><br><span class="line">B:igfheb</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:idfbge</span><br><span class="line">B:igfheb</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igdfbe</span><br><span class="line">B:igfheb</span><br><span class="line">   ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfdbe</span><br><span class="line">B:igfheb</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhdbe</span><br><span class="line">B:igfheb</span><br><span class="line">     ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhedb</span><br><span class="line">B:igfheb</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfhebd</span><br><span class="line">B:igfheb</span><br><span class="line">       ^</span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">A:igfheb</span><br><span class="line">B:igfheb</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>

<p>用一句话概括此算法的核心就是：依次遍历B集合，在A集合中找到对应项，放到与在B集合中相同的位置上。只不过 <em>Snabbdom</em> 使用了双向同时遍历来进行优化。</p>
<p>事实上，React 的 DOM Diff 算法与此也是非常类似的，只不过受限于 Fiber，只进行了单向搜索。但是即便如此， React 也引入了优化策略，尽量使得更多的元素不必移动。从本质上来看，Inferno 和 React 都利用递增子序列来进行了优化，但是 Inferno 使用算法来保证是最大递增子序列，而 React 的子序列是一定从第一个元素开始的，因此不一定是最大子序列。这在尾部元素移动到首部的时候，差异表现得更明显。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/02/11/2018-02-11-inferno-dom-diff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/11/2018-02-11-inferno-dom-diff/" class="post-title-link" itemprop="url">Inferno.js 中的 DOM Diff 算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-11 18:20:59" itemprop="dateCreated datePublished" datetime="2018-02-11T18:20:59+08:00">2018-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>已经关注 <a target="_blank" rel="noopener" href="https://infernojs.org/">Inferno.js</a> 有两年的时间，终于在刚刚不久的过去建立起了官网和文档。</p>
<p>值得特别关注的是，<em>Inferno.js</em> 提供了类 React API 的同时，在 DOM Diff 算法上借鉴了 <a target="_blank" rel="noopener" href="https://github.com/ivijs/ivi">ivijs</a>，取得了更高的效率，从而有较强的性能表现。</p>
<p>优秀的 DOM Diff 算法的核心都是在将一个 DOM 集合转换成另一个 DOM 集合的同时，尽可能地复用已有 DOM 并具有较少的 DOM 移动操作，这是由于 DOM 操作（甚至访问）的成本较高。</p>
<p><em>Inferno.js</em> 在两个 VDom 之间进行比较，从而避免了频繁访问 DOM 的性能开销。下面我们看一下它实现的 DOM Diff 算法。</p>
<p>我们假设有原始的 DOM 集合A为 “<em>dfibge</em>”，更新后的集合B为 “<em>igfheb</em>”。</p>
<p>首先得到集合B中元素在A中的原始位置，如果在A中不存在则为-1，得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A       = [d, f, i,  b, g, e];</span><br><span class="line"><span class="keyword">var</span> B       = [i, g, f,  h, e, b];</span><br><span class="line"><span class="keyword">var</span> sources = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>现在我们获取该数组的最大递增子序列的序列位置，为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seq = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>];<span class="comment">// [2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>这个数组的意义在于：“新数组中第0、1、4位置的元素在原始数组中是无需移动的”，这是我们能获取最小移动步数的关键。</p>
<blockquote>
<p>一共6个成员，3个无需移动，那么一定有3个需要操作</p>
</blockquote>
<p>现在我们从后往前遍历集合B，观察每个成员的位置是否存在于 <em>seq</em> 中，存在则不必操作，不存在则需移动。</p>
<p>首先我们需要先删除B中存在，但A中不存在的元素 <em>d</em>，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br></pre></td></tr></table></figure>

<p>观察B中最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">                  ^ pos=5</span><br></pre></td></tr></table></figure>

<p>位置是5，不存在于 <em>seq</em> 中，需要把集合A中的 <em>b</em> 移到最后，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, e, b] --- (1)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第二个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">               ^ pos=4</span><br></pre></td></tr></table></figure>

<p>位置是4，存在于 <em>seq</em> 中，无需操作。</p>
<p>观察B中倒数第三个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">            ^ pos=3</span><br></pre></td></tr></table></figure>

<p>在A中不存在，我们需要创建 <em>h</em>，并放到 <em>e</em> 的前面，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, h, e, b] --- (2)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第四个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, g, h, e, b]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">         ^ pos=2</span><br></pre></td></tr></table></figure>

<p>位置是2，不存在于 <em>seq</em> 中，需要把集合A中的 <em>f</em> 移到 <em>h</em> 的前面，此时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=[i, g, f, h, e, b] --- (3)</span><br></pre></td></tr></table></figure>

<p>观察B中倒数第五个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[i, g, f, h, e, b]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">      ^ pos=1</span><br></pre></td></tr></table></figure>

<p>位置是1，存在于 <em>seq</em> 中，无需任何操作。</p>
<p>观察B中倒数第六个元素，也是最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[f, i, b, g, e]</span><br><span class="line">B=[i, g, f, h, e, b]</span><br><span class="line">   ^ pos=0</span><br></pre></td></tr></table></figure>

<p>位置是0，存在于<em>seq</em>中，也无需任何操作。</p>
<p>此时，所有操作都已结束，仅需3步，集合A已经转换成了集合B。其中，对 <em>d</em> 的移除和对 <em>h</em> 的创建是不可避免的，除此之外，仅进行了两次DOM移动，也印证了上面提到的 6-3&#x3D;3 的操作步骤。</p>
<blockquote>
<p>我们在移动 DOM 的时候都是执行的“插在XXX之前”，是因为 DOM 中的 <em>insertBefore</em> 方法，如果存在 insertAfter，那么从前往后操作也是等效的。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2018/02/06/2018-02-07-js-inherits/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/06/2018-02-07-js-inherits/" class="post-title-link" itemprop="url">JavaScript 中继承的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-06 21:37:24" itemprop="dateCreated datePublished" datetime="2018-02-06T21:37:24+08:00">2018-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-11 18:23:50" itemprop="dateModified" datetime="2022-04-11T18:23:50+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们都知道 JavaScript 是通过原型链继承的，在不支持 class、extends 语法的环境里，继承又该如何实现呢？</p>
<p>首先我们来整理实现继承后的效果表征，假设存在两个类（函数）A 和 B，我们要实现 B 继承于 A，那么需要满足：</p>
<ol>
<li>new B() instanceof A 为真；</li>
<li>B.prototype.constructor &#x3D;&#x3D;&#x3D; B 为真；</li>
<li>如果 A.foo &#x3D; 1，则 B.foo &#x3D; 1 为真，即静态变量可继承；</li>
<li>在普通方法 foo 中可以调用 super.foo() 调用基类方法；</li>
<li>在构造方法中可以调用 super() 调用基类构造方法</li>
</ol>
<p>在很多年前，jQuery 作者 <em>John Resig</em> 曾写过一个继承的<a target="_blank" rel="noopener" href="https://johnresig.com/blog/simple-javascript-inheritance/">实现</a>，在那个还在 ES3 语法的时代已经非常难得。在今天看来，这种实现方式的语义已经远远落后，同时也不能实现静态变量。</p>
<hr>
<p>下面我们来一步一步地去理解 babel 的实现方式。</p>
<p>首先定义两个类（函数），以及子类的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>想实现 B 继承于 A，那边必然 <em>b instanceof B</em> 为真，根据 instanceof 的意义，一定有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="property">__proto__</span>.<span class="property">__proto__</span>... === A.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>我们知道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="property">__proto__</span> === B.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>那么我们只需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>... === A.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>于是我们覆写 <em>B.prototype</em>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<p>这样一定有 <em>A.prototype.isPrototypeOf(B.prototype)</em> 为真。</p>
<p>现在我们已经实现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b <span class="keyword">instanceof</span> A === <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>也就是说第一条我们已经实现了，下面看第二条，只需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = B;</span><br></pre></td></tr></table></figure>

<p>或者更优雅一些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在我们要实现静态成员的继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br></pre></td></tr></table></figure>

<p>目前为止，我们定义的是两个空类，现在我们为他们增加 name 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; B</span></span><br></pre></td></tr></table></figure>

<p>现在我们要在 B 的 name 中获取父类的 name 属性，那么我们就需要找到 B.prototype 中的 name。</p>
<p>在 B 环境中，灵活的做法是通过 B.prototype 找到 A.prototype，根据 *B.prototype &#x3D; Object.create(A.prototype)*，我们知道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure>

<p>于是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">            <span class="keyword">var</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; AB</span></span><br></pre></td></tr></table></figure>

<p>这就实现了 super.name 的效果。当然，我们假设 B 的父类是定义了 name 的，如果没有找到 name，那应该沿着原型链继续向上寻找。因此更健壮的写法是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = B.<span class="property"><span class="keyword">prototype</span></span>, desc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(sup);</span><br><span class="line">                <span class="keyword">if</span> (!sup) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span>(!desc);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> (desc ? desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) : <span class="literal">undefined</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">name</span>); <span class="comment">// =&gt; A</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">name</span>); <span class="comment">// =&gt; AB</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里没有考虑 name 不是 getter 的情形，不过原理类似，不再冗述。</p>
</blockquote>
<p>最后我们来实现在构造方法中调用 super()。显然，实质是在 B 函数中找到函数 A，根据 *Object.setPrototypeOf(B, A)*，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B).<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们为 A 添加一个 age 构造参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(B).<span class="title function_">call</span>(<span class="variable language_">this</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: A,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: B,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sup = B.<span class="property"><span class="keyword">prototype</span></span>, desc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                sup = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(sup);</span><br><span class="line">                <span class="keyword">if</span> (!sup) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(sup, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span>(!desc);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> (desc ? desc.<span class="property">get</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) : <span class="literal">undefined</span>) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>(<span class="number">18</span>).<span class="property">age</span>); <span class="comment">// =&gt; 18</span></span><br></pre></td></tr></table></figure>

<p>于是，一个基本的继承的手写版本就实现了，当然，babel 还考虑了更多细节，比如构造方法有返回值的情况等等，但基本的继承原理就是这个样子。</p>
<p>下图很好地反应了诸多对象的关系。值得一提的是， <em>b</em> 也可能成为下一级类的 prototype，你可以清晰地看到通过 __proto__ 搜索原型链的轨迹。</p>
<p><img src="/images/inherits/inherit.jpg" alt="js-inherit"></p>
<hr>
<p>在现代浏览器的不断迭代下，已经有大部分版本都实现了对 class 关键字和继承的原生支持，相信在不久的将来，就无需在这么麻烦地实现继承了。无论如何，JavaScript 继承的原理仍然是不变的，上面这些内容有助于理解原型链是怎么样工作的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yanni4night</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>

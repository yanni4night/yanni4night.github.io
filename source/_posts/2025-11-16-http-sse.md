---
layout: post
title: "SSE实战入门"
date: 2025-11-16 17:01:00 +0800
categories: js
---

## 1. 什么是Server-Sent Events (SSE)

Server-Sent Events (SSE) 是一种基于HTTP协议的服务器向客户端单向推送数据的实时通信技术。它允许服务器主动、持续地向客户端发送数据，而不需要客户端频繁发起请求，从而实现高效的实时数据传输。

与传统的HTTP请求-响应模式不同，SSE建立的是一种持久连接，服务器可以在任意时间点向客户端推送新信息。这种技术特别适用于需要服务器主动向客户端发送更新的场景，如实时通知、状态更新、数据监控等。

## 2. SSE的重要性与价值

在Web开发技术演进的历程中，SSE凭借其独特的优势占据了重要地位：

### 2.1 技术定位与生态系统

SSE与WebSocket、Polling一起，构成了Web实时通信的三大主要技术。作为一种基于标准HTTP的技术，SSE与现有Web基础设施完美契合，能够充分利用现有的HTTP生态系统，包括安全机制、代理服务器、缓存策略等。这种兼容性使其在企业级应用和复杂网络环境中具有显著优势。

### 2.2 实现优势与技术特性

相比其他实时通信技术，SSE具有以下核心优势：

1. **实现简单性**
   - 基于标准HTTP，无需特殊的服务器配置或协议处理
   - 浏览器原生支持，学习曲线平缓
   - 比WebSocket更易于实现和维护

2. **资源效率**
   - 比传统轮询(polling)显著节省网络资源和服务器负载
   - 比WebSocket更轻量，特别适合单向推送场景
   - 内置自动重连机制，减少手动错误处理的复杂性

3. **客户端兼容性**
   - 所有现代浏览器都原生支持EventSource API
   - 无需额外客户端库，减少应用体积
   - 可通过简单的polyfill支持更广泛的浏览器环境

## 3. SSE的应用场景

SSE技术在多个领域展现出强大的应用价值：

### 3.1 AI与智能交互领域

随着AI技术的快速发展，SSE在AI应用中的重要性日益凸显：

- **流式响应生成**：AI模型（如GPT、Claude、Gemini等）生成文本时的逐字输出体验，提供更自然的人机交互
- **实时状态更新**：AI Agent思考过程、工具调用状态的实时反馈，增强用户对AI行为的理解
- **多模态内容逐步展示**：文字、代码、图表等内容的顺序呈现，提升复杂信息的接收体验
- **长期对话上下文维护**：保持长连接状态下的对话连贯性，优化连续交互场景
- **模型推理进度可视化**：展示AI思考、检索、生成各阶段的实时状态，提高透明度

### 3.2 通用Web应用场景

除AI领域外，SSE在各种Web应用中也有广泛应用：

- **实时通知与警报系统**：如新消息提醒、系统警告、订单状态更新
- **数据监控与仪表盘**：服务器性能指标、网络状态、业务指标的实时更新
- **多人协作应用**：文档编辑状态、在线用户列表、操作冲突提示的同步
- **实时数据可视化**：股票行情、传感器数据、系统监控图表的动态更新
- **游戏状态同步**：回合制游戏的状态更新、排行榜实时变化

接下来，我们将通过理论讲解和实例代码，系统地介绍SSE技术的各个方面，从基础概念到实际应用，进而理解和掌握这一重要的实时通信技术。

## 4. 项目结构设计

为了更好地理解和实践SSE技术，我们设计了一个简洁明了的项目结构。这个结构虽然简单，但涵盖了实现SSE通信所需的核心组件，包括服务器端和客户端两部分。通过这种结构，我们可以清晰地展示SSE的工作原理和实现方式。

我们将创建以下文件结构：

```
/sse-project
  /public         # 存放客户端静态资源
    index.html    # 客户端SSE实现页面，包含EventSource和Fetch API示例
  index.js        # Node.js服务器端，负责创建HTTP服务器和处理SSE连接
```

这个项目结构体现了典型的前后端分离设计：服务器端使用Node.js处理SSE连接和消息推送，客户端通过浏览器API接收实时数据流。在接下来的章节中，我们将详细介绍浏览器端和服务器端的具体实现代码。

## 5. 浏览器端实现

### 5.1 SSE客户端实现的两种主要方式

浏览器端实现SSE主要有两种方式：
1. **EventSource API** - 浏览器原生的SSE专用接口
2. **Fetch API + ReadableStream** - 使用Fetch API和流处理实现SSE

### 5.2 EventSource API 基础

EventSource是浏览器提供的专门用于SSE的原生接口，使用非常简单直接。

#### 基本实现

```javascript
// 创建EventSource实例，连接到服务器的SSE端点
const eventSource = new EventSource('/events');

// 监听message事件，这是默认的事件类型
 eventSource.onmessage = function(event) {
  const data = event.data;
  console.log('收到服务器数据:', data);
  // 这里可以处理收到的数据，比如更新UI
};

// 监听open事件，连接建立时触发
 eventSource.onopen = function(event) {
  console.log('连接已建立');
};

// 监听error事件，连接出错时触发
 eventSource.onerror = function(error) {
  console.error('连接发生错误:', error);
  // 可以在这里处理重连逻辑
};
```

#### 自定义事件类型

除了默认的`message`事件，服务器也可以发送自定义类型的事件。客户端可以通过`addEventListener`方法监听这些自定义事件：

```javascript
// 监听自定义事件"update"
 eventSource.addEventListener('update', function(event) {
  const data = event.data;
  console.log('收到更新事件:', data);
});

// 监听自定义事件"notification"
 eventSource.addEventListener('notification', function(event) {
  const data = JSON.parse(event.data);  // 如果服务器发送的是JSON格式数据
  console.log('收到通知:', data.title, data.message);
});
```

#### 关闭连接

当不再需要接收服务器推送的数据时，应该关闭EventSource连接以释放资源：

```javascript
// 关闭SSE连接
 eventSource.close();
console.log('连接已关闭');
```

### 5.3 使用Fetch API实现SSE

除了EventSource，我们还可以使用Fetch API结合ReadableStream来实现SSE功能。这种方式提供了更多的灵活性，特别是在需要发送POST请求或自定义请求头的场景。

#### 基本实现

```javascript
async function connectSSEWithFetch() {
  try {
    // 使用Fetch API发起请求
    const response = await fetch('/events', {
      method: 'GET', // 也可以是POST
      headers: {
        'Accept': 'text/event-stream',
        'Authorization': 'Bearer token123' // 可以添加自定义认证头
      },
      credentials: 'include' // 包含cookies
    });

    // 检查响应是否成功
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // 获取响应体的可读流
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    // 逐块处理流数据
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) {
        console.log('SSE连接已关闭');
        break;
      }

      // 解码新的数据块并添加到缓冲区
      buffer += decoder.decode(value, { stream: true });
      
      // 处理缓冲区中的完整事件
      processSSEBuffer(buffer);
    }
  } catch (error) {
    console.error('SSE连接错误:', error);
    // 实现重连逻辑
  }
}

// 处理SSE格式的数据缓冲区
function processSSEBuffer(buffer) {
  // 分割事件（每个事件以两个连续的换行符结束）
  const eventSeparator = '\n\n';
  const events = buffer.split(eventSeparator);
  
  // 处理所有完整的事件
  for (let i = 0; i < events.length - 1; i++) {
    const eventData = events[i].trim();
    if (!eventData) continue;
    
    // 解析事件数据
    parseAndDispatchEvent(eventData);
  }
  
  // 保留最后一个不完整的事件块
  if (events.length > 0) {
    buffer = events[events.length - 1];
  }
}

// 解析SSE事件并分发
function parseAndDispatchEvent(eventData) {
  const lines = eventData.split('\n');
  let eventType = 'message';
  let data = '';
  
  // 解析事件的每一行
  for (const line of lines) {
    if (line.startsWith('event:')) {
      eventType = line.substring(6).trim();
    } else if (line.startsWith('data:')) {
      data += line.substring(5).trim() + '\n';
    }
  }
  
  // 移除最后一个换行符
  data = data.trim();
  
  // 分发事件
  console.log(`收到${eventType}事件:`, data);
  
  // 这里可以根据事件类型进行不同的处理
  // 或者触发自定义事件
}
```

### 5.4 EventSource与Fetch API实现SSE的比较

| 特性 | EventSource | Fetch API + ReadableStream |
|------|-------------|----------------------------|
| **请求方法** | 仅支持GET请求 | 支持GET、POST等所有HTTP方法 |
| **请求头** | 有限的自定义能力 | 完全自定义请求头 |
| **自动重连** | 内置自动重连机制 | 需要手动实现重连逻辑 |
| **事件解析** | 自动解析SSE格式 | 需要手动解析SSE格式 |
| **浏览器支持** | 所有现代浏览器，IE不支持 | 现代浏览器，IE不支持 |
| **代码复杂度** | 低，API简单 | 较高，需要手动处理流和解析 |
| **灵活性** | 较低，功能固定 | 高，可以完全控制整个过程 |
| **认证支持** | 基础认证，Cookie | 支持所有认证方式，包括Bearer Token |

#### 何时选择EventSource

- 简单的SSE实现需求
- 只需要GET请求
- 希望利用自动重连功能
- 代码简洁性优先
- 低复杂度的应用

#### 何时选择Fetch API

- 需要使用POST或其他HTTP方法
- 需要自定义复杂的请求头或认证方式
- 需要更精细地控制连接生命周期
- 需要与现有Fetch API代码集成
- 复杂的企业级应用

## 6. Node.js服务器端实现

### 6.1 服务器基础配置

使用Node.js原生的`http`模块，我们可以轻松创建一个支持SSE的服务器。关键是设置正确的响应头并保持连接打开：

```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

// 创建HTTP服务器
const server = http.createServer((req, res) => {
  if (req.url === '/events') {
    // 处理SSE连接请求
    handleSSE(req, res);
  } else if (req.url === '/') {
    // 提供主HTML页面
    serveFile(res, '/public/index.html', 'text/html');
  } else {
    // 提供静态文件
    serveFile(res, req.url, getContentType(req.url));
  }
});

// 启动服务器
const PORT = 3000;
server.listen(PORT, () => {
  console.log(`服务器运行在 http://localhost:${PORT}`);
});

// 辅助函数：提供静态文件
function serveFile(res, filePath, contentType) {
  const fullPath = path.join(__dirname, filePath);
  
  fs.readFile(fullPath, (err, data) => {
    if (err) {
      res.writeHead(404);
      res.end('文件未找到');
      return;
    }
    
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(data);
  });
}

// 辅助函数：获取内容类型
function getContentType(filePath) {
  const ext = path.extname(filePath);
  switch (ext) {
    case '.html': return 'text/html';
    case '.js': return 'text/javascript';
    case '.css': return 'text/css';
    default: return 'text/plain';
  }
}
```

### 6.2 SSE处理函数

下面是处理SSE连接的核心函数，它设置必要的HTTP头并保持连接打开以发送事件：

```javascript
// 处理SSE连接的函数
function handleSSE(req, res) {
  // 设置SSE相关的HTTP头
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*' // 允许跨域，生产环境应该限制具体域名
  });

  // 发送欢迎消息
  sendSSE(res, 'message', '连接已建立');

  // 定期发送更新消息
  const intervalId = setInterval(() => {
    const data = {
      timestamp: new Date().toLocaleTimeString(),
      random: Math.floor(Math.random() * 100)
    };
    sendSSE(res, 'update', JSON.stringify(data));
  }, 2000);

  // 发送自定义事件示例
  setTimeout(() => {
    sendSSE(res, 'notification', JSON.stringify({
      title: '重要通知',
      message: '这是一个通过SSE发送的通知！',
      time: new Date().toLocaleTimeString()
    }));
  }, 5000);

  // 当连接关闭时清理资源
  req.on('close', () => {
    clearInterval(intervalId);
    console.log('SSE连接已关闭');
  });
}

// 发送SSE消息的辅助函数
function sendSSE(res, eventType, data) {
  res.write(`event: ${eventType}\n`);
  res.write(`data: ${data}\n\n`);
}
```

### 6.3 SSE消息格式说明

SSE消息必须遵循特定的格式：

1. `event: eventName` - 可选，指定事件类型
2. `data: messageData` - 必须，包含消息内容
3. 两个连续的换行符 (`\n\n`) 表示消息结束

如果消息内容多行，可以每行都以`data:`开头，例如：

```
data: 第一行数据
data: 第二行数据

```

Node.js服务器使用`res.write()`而不是`res.end()`来保持连接打开，这样可以持续发送数据。

## 7. SSE前端实现方案与大模型应用

在实际生产环境中，使用原生EventSource API虽然直接，但通过封装框架可以大大简化开发并提高可靠性。以下是SSE在生产环境中的主要应用方式和常用封装框架：

### 7.1 前端框架SSE封装

#### React生态系统

1. **useEventSource Hook**
   - 社区中有多个轻量级Hook库，如`react-use-event-source`和`use-sse`
   - 提供自动连接管理、错误处理和组件生命周期集成
   - 简单示例：
     ```javascript
     import { useEventSource } from 'react-use-event-source';
     
     function MyComponent() {
       const { data, error, isConnected } = useEventSource('/api/stream', {
         onOpen: () => console.log('连接已建立'),
         onError: (e) => console.error('连接错误', e)
       });
       
       return <div>{data || '等待数据...'}</div>;
     }
     ```

2. **React Query SSE支持**
   - React Query通过扩展可以支持SSE数据的实时更新
   - 适合需要将SSE数据与应用状态管理集成的场景

#### Vue生态系统

1. **Vue SSE插件**
   - `vue-sse`插件提供了Vue组件与SSE的无缝集成
   - 支持Vue 2和Vue 3，具有响应式数据绑定

2. **Pinia/Vuex集成**
   - 可以通过插件方式将SSE数据流直接注入状态管理
   - 实现全局状态的实时更新

### 7.2 大模型API SSE封装

各大AI模型提供的官方SDK都包含了对SSE流式响应的优化封装：

1. **OpenAI SDK**
   - 提供了对SSE流的Promise和AsyncIterator支持
   - 自动处理分块响应和重连逻辑

2. **Anthropic SDK**
   - 针对Claude模型优化的流式处理
   - 提供更丰富的事件类型和状态管理

3. **Google Generative AI SDK**
   - 为Gemini模型提供流式响应支持
   - 包含自动重试和错误恢复机制

### 7.3 通用SSE增强库

1. **EventSource-Polyfill**
   - 为不支持EventSource的旧浏览器提供兼容层
   - 支持现代浏览器中的额外功能扩展

2. **sse.js**
   - 增强型EventSource实现，支持自定义头部和跨域配置
   - 提供更灵活的重连控制和事件处理

3. **fetch-event-source**
   - 基于Fetch API的现代化SSE实现
   - 支持POST请求和自定义认证，适合需要发送复杂请求的场景

### 7.4 生产环境最佳实践

1. **连接管理**
   - 实现指数退避重连策略
   - 监控连接健康状态，主动检测断开

2. **性能优化**
   - 批量处理DOM更新以避免频繁渲染
   - 使用流式解析大型JSON响应

3. **安全性**
   - 使用适当的认证和授权机制保护SSE端点
   - 实现请求限流和连接数控制

在选择SSE实现方案时，应根据项目的具体需求、技术栈和团队熟悉程度来决定。对于简单应用，原生EventSource可能已足够；而对于复杂的生产环境应用，使用成熟的封装框架可以显著提高开发效率和应用稳定性。

选择适合的框架或服务取决于具体项目需求、技术栈和团队熟悉程度。对于简单的应用，原生实现可能已经足够；而对于复杂的企业级应用，使用成熟的框架可以提高开发效率和代码可维护性。
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yanni4night.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、前言从 qiankun 开始，沙箱（或沙盒、sandbox）已经成了几乎所有微前端框架的标配功能。但事实上其内部涉及实现的大量细节，导致每家的能力参差不齐。 严格来说，沙箱并没有遵循的标准，在一些细节上的实现也没有对错，具体行为还是要取决于业务的需求。 Node.js 的vm 模块并不能直接移植到浏览器端，一个很大的原因在于浏览器涉及的视图（包括 DOM、URL）无法被拷贝，只能共享，那么共享">
<meta property="og:type" content="article">
<meta property="og:title" content="沙箱是如何工作的">
<meta property="og:url" content="https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/index.html">
<meta property="og:site_name" content="人过不留名 雁过不留声">
<meta property="og:description" content="一、前言从 qiankun 开始，沙箱（或沙盒、sandbox）已经成了几乎所有微前端框架的标配功能。但事实上其内部涉及实现的大量细节，导致每家的能力参差不齐。 严格来说，沙箱并没有遵循的标准，在一些细节上的实现也没有对错，具体行为还是要取决于业务的需求。 Node.js 的vm 模块并不能直接移植到浏览器端，一个很大的原因在于浏览器涉及的视图（包括 DOM、URL）无法被拷贝，只能共享，那么共享">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-14T03:32:48.000Z">
<meta property="article:modified_time" content="2023-01-14T04:08:38.580Z">
<meta property="article:author" content="Yanni4night">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/","path":"2023/01/14/2023-01-14-how-sandbox-works/","title":"沙箱是如何工作的"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>沙箱是如何工作的 | 人过不留名 雁过不留声</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SVVTY641FP"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SVVTY641FP","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?102a03a6de835cd378834b32e2639fbe"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">人过不留名 雁过不留声</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">夜莺</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F%E9%9A%94%E7%A6%BB"><span class="nav-number">2.</span> <span class="nav-text">二、变量隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%B1%9E%E6%80%A7%E7%9B%91%E8%A7%86"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 属性监视</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%B8%BB%E5%8A%A8%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 主动变量逃逸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 函数属性上下文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">三、执行 JavaScript 代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-eval"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-ESM"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 ESM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81DOM-%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">四、DOM 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9B%BA%E5%AE%9A-DOM"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 固定 DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%AD%98%E9%87%8F-DOM"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 存量 DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%96%B0%E5%A2%9E-DOM"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 新增 DOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95"><span class="nav-number">6.</span> <span class="nav-text">六、未来发展</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanni4night"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yanni4night</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yanni4night" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanni4night" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yanni4night@gmail.com" title="E-Mail → mailto:yanni4night@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yanni4night.github.io/2023/01/14/2023-01-14-how-sandbox-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yanni4night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="沙箱是如何工作的 | 人过不留名 雁过不留声">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          沙箱是如何工作的
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-01-14 11:32:48 / 修改时间：12:08:38" itemprop="dateCreated datePublished" datetime="2023-01-14T11:32:48+08:00">2023-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">微前端</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/01/14/2023-01-14-how-sandbox-works/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/01/14/2023-01-14-how-sandbox-works/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>从 <em>qiankun</em> 开始，沙箱（或沙盒、sandbox）已经成了几乎所有微前端框架的标配功能。但事实上其内部涉及实现的大量细节，导致每家的能力参差不齐。</p>
<p>严格来说，沙箱并没有遵循的标准，在一些细节上的实现也没有对错，具体行为还是要取决于业务的需求。</p>
<p><em>Node.js</em> 的<a href="https://nodejs.org/dist/latest-v18.x/docs/api/vm.html" target="_blank">vm 模块</a>并不能直接移植到浏览器端，一个很大的原因在于浏览器涉及的视图（包括 DOM、URL）无法被拷贝，只能共享，那么共享到什么水平就成了沙箱方案能力差别的衡量标准之一。</p>
<h2 id="二、变量隔离"><a href="#二、变量隔离" class="headerlink" title="二、变量隔离"></a>二、变量隔离</h2><p>沙箱的基础能力就是隔离上下文，让下列操作都只局限在特定的上下文内，不会干扰到外部：</p>
<ul>
<li>删除已有变量，如 <em>delete obj.a</em> 或 <em>Relect.deleteProperty(obj, ‘a’)</em> ；</li>
<li>修改已有变量<ul>
<li>修改取值，如 <em>obj.a&#x3D;1</em> 或 <em>Reflect.set(obj, ‘a’, 1)</em> 或 <em>Reflect.defineProperty(obj, ‘a’, { value: 1 })</em></li>
<li>修改描述符，如 <em>Reflect.defineProperty(obj, ‘a’, { writable: false })</em></li>
<li>修改 frozen、sealed、extensible 状态，如 <em>Object.freeze(obj.a)</em> 、 <em>Object.seal(obj.a)</em> 或 <em>Object.preventExtensions(obj.a)</em></li>
<li>修改原型链，如 <em>Object.setPrototypeOf(obj.a, null)</em></li>
</ul>
</li>
<li>创建新的变量，如 <em>obj.a&#x3D;1</em> 或 <em>Relect.defineProperty(obj, ‘a’, {value: 1})</em></li>
</ul>
<p>上面的 <strong>obj</strong> 对象即指上下文对象，在浏览器中通常是 <em>window</em> 或 <em>document</em> ，这两个全局对象。但事实上，window 下的所有属性都可以直接取到，如 <em>addEventListener</em> 、 <em>name</em> 、 <em>CSS</em> 、 <em>location</em> 、 <em>history</em> 、 <em>navigator</em> 、 <em>HTMLElement</em> 等等，不胜枚举。因此， <strong>沙箱不可能监视所有变量的属性删除&#x2F;修改&#x2F;创建，因此也就不可能实现“完美”沙箱</strong> ，毕竟你不能遍历 window 下的所有属性，都监视一遍。</p>
<p><strong>with(){}</strong> 的做法不在考虑范围之内，对性能损耗过大。</p>
<p>这个事实带来的后果是，如果你想逃逸出沙箱，是非常容易的，比如 <em>navigator.no&#x3D;1</em> 。所以，沙箱在微前端中有使用价值的前提是， <strong>你必须尽可能保障对全局变量的访问是可控、无副作用的</strong> ，这是沙箱的脆弱之处，也是一种规范。接下来我们将在这一规范下继续讨论沙箱的实现问题，假设我们只考量对 window 和 document 这两个变量的属性监视。</p>
<h3 id="2-1-属性监视"><a href="#2-1-属性监视" class="headerlink" title="2.1 属性监视"></a>2.1 属性监视</h3><p>毫无疑问，在现代浏览器中，Proxy 是监视对象的最佳方案，通过它，我们应该可以被通知且控制获取、修改、删除、遍历等几乎所有操作。但是，proxy 对象真的可以为所欲为吗？</p>
<p>观察下列代码：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/yanni4night/xms2nkpa/15/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>这里涉及到了关于 <em>configurable</em> 导致的错误，事实上，有大量的操作都是被 proxy 所禁止的，在 <em>ECMA262</em> 上的<a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>部分搜索 <strong>Invariants</strong> 能查询得到。因此 proxy 对象并非无所不能，它无法任意伪装原始对象的行为， <strong>该失败的必须失败</strong> 。相关规则包括如下：</p>
<table class="table">
    <thead>
        <th>对象操作</th>
        <th>不变量</th>
    </thead>
    <tbody>
        <tr>
            <td>defineProperty</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么使用defineProperty新增属性时不能返回true；</li>
                    <li>如果目标对象没有不可配置属性a，则代理对象也不能用defineProperty在将属性a定义成不可配置时时返回true；</li>
                    <li>如果目标对象没有不可配置且不可写的属性a，则代理对象也不能用defineProperty在将不可配置属性a定义成不可写时返回true</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>deleteProperty</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用deleteProperty删除a时不能返回true；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>get</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象在用get取值a时必须返回和目标对象相同值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少get的存取类型，那么代理在用get取值a时必须返回undefined</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getOwnPropertyDescriptor</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时不能返回undefined；</li>
                    <li>如果目标对象是不可扩展的，且没有有属性a，那么代理对象在用getOwnPropertyDescriptor获取a时必须返回undefined；</li>
                    <li>除非目标对象有不可配置且不可写的属性a，那么代理对象在用getOwnPropertyDescriptor获取a时就不能是不可配置且不可写的；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>getPrototypeOf</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用getPrototypeOf时必须返回与在目标对象上调用的返回值</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>has</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置的属性a，那么代理对象在用has获取a时不能返回false；</li>
                    <li>如果目标对象是不可扩展的，且有属性a，那么代理对象在用has获取a时不能返回false；</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>ownKeys</td>
            <td>
                <ol>
                    <li>如果目标对象是不可扩展的，那么代理对象在用ownKeys时必须返回目标对象的全部属性名，不能包含额外属性名</li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>set</td>
            <td>
                <ol>
                    <li>如果目标对象有不可配置且不可写的属性a，那么代理对象就不能用set给a设置不同的值；</li>
                    <li>如果目标对象的属性a是不可配置的，且是缺少set的存取类型，那么代理在用set设值a时必须返回false</li>
                </ol>
            </td>
        </tr>
    </tbody>
</table>

<p>看似复杂，但实际总结来看，就是代理对象必须遵循一个原则： <strong>操作的结果要真实反应 target 的最新状态。</strong></p>
<p>举几个例子：</p>
<ul>
<li>如果Reflect.has(proxyObj, ‘a’)返回true，那么target就必须不能有一个不可配置的属性a；</li>
<li>如果Reflect.set(proxyObj, ‘a’, 1)返回true，那么target对象必然不能是不可扩展的，也不可以有一个不可写也不可配置的属性a</li>
</ul>
<p>如下的做法，直接代理原始 window、document 肯定是不可以的，根据上面的 Invariants 可知我们几乎必须把属性同步给原始的 window、document 才能不报错，显然违背我们做沙箱的初衷。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="variable language_">window</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>因此，通常的做法是把一个 <strong>新创建的对象</strong> 当作原始对象进行代理，下文简称为 <strong>target</strong> 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>所有的操作几乎都是最终体现在 target 对象上的，个别稍有例外。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">defineProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey, attributes: PropertyDescriptor</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="property">defineProperty</span>)(target, p, attributes);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deleteProperty</span>: <span class="keyword">function</span> (<span class="params">target: Window, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getOwnPropertyDescriptor</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="title class_">PropertyDescriptor</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">has</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, p);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params">target: T</span>): <span class="title class_">ArrayLike</span>&lt;<span class="built_in">string</span> | <span class="built_in">symbol</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey, value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getPrototypeOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">window</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但显然这样是有严重问题的，因为 target 是伪装的 Window 对象，它身上没有任何属性，这不但会影响 get、getOwnPropertyDescriptor、has、ownKeys 这些只读操作的结果，由于 Proxy 的规则，同样也会影响 defineProperty、deletePrperty、set 这些写操作的结果。</p>
<p>举个例子，本来真实 window 对象上有一个不可配置的属性 foo，正常来说，我们用 defineProxy 修改其描述符类型时一定会报错，但是 target 本身并没有任何属性，Reflect.defineProperty(target)却是成功的，不符合期望。</p>
<p>于是，业界常规的做法都是会把 <strong>原始对象的自身属性拷贝到 target 中，特别是那些不可配置的属性</strong> 。这样无论是读操作还是写操作，其结果都真实反应到了代码对象的 target 中，不会被任何 Proxy 原则所影响。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="variable language_">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> descriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, key);</span><br><span class="line">  <span class="keyword">if</span> (!descriptor.<span class="property">configurable</span>) <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, p, descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步的成本稍高，但是又是必须的。在具体的实现策略上也可以区分为一次性拷贝和懒惰式拷贝，即用到某属性时才执行拷贝。</p>
<h3 id="2-2-主动变量逃逸"><a href="#2-2-主动变量逃逸" class="headerlink" title="2.2 主动变量逃逸"></a>2.2 主动变量逃逸</h3><p>虽然沙箱的关键作用就是为了限制变量的访问和变更范围，但是毕竟在同一个浏览器页面之下，难免有需要例外放行的 case。我们称这类变量为 exception 或者 escaped，这种功能称之为“主动变量逃逸”。</p>
<p>实现主动变量逃逸比较简单，以 set 和 get 操作为例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不过别忘记了 Proxy 的那些 Invariants 限制，上述这些操作的结果都要反应到 target 身上，所以最后还是得把原始对象（如 window）上的属性同步到 target 上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Window</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target: T, p: PropertyKey <span class="comment">/*, receiver: any */</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="variable language_">window</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, p);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: T,</span></span><br><span class="line"><span class="params">    p: PropertyKey,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span> <span class="comment">/*, receiver: unknown */</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEscaped</span>(p)) &#123;</span><br><span class="line">      <span class="comment">// 同步到target中</span></span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        target,</span><br><span class="line">        p,</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, p)</span><br><span class="line">      );</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="variable language_">window</span>, p, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, p, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-函数属性上下文"><a href="#2-3-函数属性上下文" class="headerlink" title="2.3 函数属性上下文"></a>2.3 函数属性上下文</h3><p>上面提到，我们需要把原始对象（window、document）的属性同步到 target 对象中，Proxy 才会不受到 Invariants 的影响，能更真实的模拟读写操作。</p>
<p>我们看下面一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/nhtwo0x2/4/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>再来看这样一个例子：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/yanni4night/1buvLtag/2/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>有这样一类函数，它们只能在指定的上下文中执行，即便是 Proxy 也不可以，否则在 Chrome 下就会报告 <strong>Illegal invocation</strong> 错误。在 Firefox 和 Safari 上的错误信息会更通俗易懂一些。</p>
<p>目标没有很好的办法来解决这个问题，毕竟函数内部的逻辑是无法预测的，只能尽可能兼容。一些策略有：</p>
<ul>
<li>如果属性名是 constructor，无需特殊处理；</li>
<li>如果属性名以大些字母开头， <strong>认为它们是构造函数</strong> ，无需特殊处理；</li>
<li>创建包装函数来锁定上下文:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newValueInTarget = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">unknown</span>[]</span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="comment">// 小写字母也可能是构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(valueInRaw, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(valueInRaw, raw, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>一些特殊属性的处理，例如 window 上的 eval、isFinite、isNaN、parseFloat、parseInt、hasOwnProperty、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent，直接走主动变量逃生即可</li>
</ul>
<h2 id="三、执行-JavaScript-代码"><a href="#三、执行-JavaScript-代码" class="headerlink" title="三、执行 JavaScript 代码"></a>三、执行 JavaScript 代码</h2><p>上面讨论的是沙箱的最关键能力——变量隔离，但无论实现怎样的能力，子应用的 JS 代码还是要得到执行，那么该如何执行的？</p>
<h3 id="3-1-eval"><a href="#3-1-eval" class="headerlink" title="3.1 eval"></a>3.1 eval</h3><p>业界普遍的做法是异步 fetch 到源代码，然后 eval 它，虽然需要跨域环境的支持，但并不是难事。只是 eval 需要一些技巧。</p>
<p>首先，eval 需要在真正的 window 上下文中执行，避免调用环境的影响，这一点，目前已经有比较明确的实现方案，就是“间接调用”：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evalScript</span>(<span class="params">code: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span>, <span class="built_in">eval</span>)(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，利用函数入参来改变一些全局变量名的作用域，将其指向既定的对象，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, self, parent, top, globalThis, document) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.window, winProxy.self, winProxy.parent, winProxy.top, winProxy.globalThis, winProxy.document)`</span>);</span><br></pre></td></tr></table></figure>

<p>从这里也能看出，如果直接引用如 location、navigator、history 将无法被沙箱捕获，你需要用 window.location、window.navigator、window.history 的方法。进而可以推断出你在全局定义的变量，也必须以 window 属性的方式来读取，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span> <span class="attr">entry</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>像上面这种 case，如果不以 window.loadStartTime 的方式能不能读取得到呢？也有一些技巧可做到。</p>
<p>比如使用嵌套递归作用域的方式来实现，相当于每执行一次 JS 之后，就会为下一次执行生成一个新的嵌套上下文，这样后面的 JS 就可以直接读取上次的变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现机理稍有复杂，理论上也会带来额外的性能开销，而且对于下面这种双向访问的场景也无法支持：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadStartTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendLog</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 访问未预定义变量</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">sendToServer</span>(&#123; loadCost &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> loadCost = <span class="title class_">Date</span>.<span class="title function_">now</span>() - loadStartTime;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./entry.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过仍然具有一定的价值，对于以 HTML 作为 entry 的子应用的容纳范围更广，子应用的灵活度更高。</p>
<h3 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h3><p>有时，需要暴露给子应用的 JS 一些临时的虚拟变量，比如 qiankun 提供的 _<strong>_POWERED_BY_QIANKUN__</strong> ，而且允许不同子应用读取到的同一名称的变量有不同的取值。</p>
<p>如果不开启沙箱的话，这一功能反而困难，需要在 window 上定义变量，然后以同步的形式运行子应用 JS 代码，最后在从 window 上移除掉。这个过程不但很可能和 window 上已经有的同名变量冲突，而且也只能保证同步代码中能读取到，异步代码中就读不到。举例说明：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">__IN_MICRO_ENV__</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在沙箱环境中，实现环境变量更简单，而且可以不受同步&#x2F;异步的影响，可以持续访问。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evalScript(<span class="string">`;</span></span><br><span class="line"><span class="string">    (function (window, document, __IN_MICRO_ENV__) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;appCode&#125;</span></span></span><br><span class="line"><span class="string">    &#125;).call(winProxy, winProxy.document, winProxy.__IN_MICRO_ENV__)`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-ESM"><a href="#3-3-ESM" class="headerlink" title="3.3 ESM"></a>3.3 ESM</h3><p><strong>ESM</strong> 格式的 JS 代码不能直接 eval 来执行。事实上，浏览器还未提供能直接运行 ESM 源码的方法。Garfish 采取来将源码转换成 URI 的方式实现了一定程度的 eval 能力，但是需要正则匹配 import 指令，存在一定的隐患。即便如此，因为不能用函数直接封装 ESM 源码，因此也无法实现沙箱运行。因此，garfish 还实现了一套运行时转译 ESM 的机制，但是对性能有较大影响，相信其稳定性也存在安全隐患。</p>
<h2 id="四、DOM-结构"><a href="#四、DOM-结构" class="headerlink" title="四、DOM 结构"></a>四、DOM 结构</h2><p>一般来说，子应用有自认为的 DOM 环境，比如 html、body、head 以及#app 等等。</p>
<h3 id="4-1-固定-DOM"><a href="#4-1-固定-DOM" class="headerlink" title="4.1 固定 DOM"></a>4.1 固定 DOM</h3><p>在沙箱环境中，如果把真正的 html、body、head 暴露给子应用，那么它很有可能在上面做一些副作用的操作，比如插入新 DOM、修改样式等等。为了避免这种情况，微前端框架一般都会给子应用生成一个模拟的 DOM 结构，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pseudo-html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pseudo-title</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pseudo-body</span>&gt;</span><span class="tag">&lt;/<span class="name">pseudo-body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pseudo-html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DOM API 中的 <strong>document.documentElement</strong> 、 <strong>document.body</strong> 、 <strong>document.head</strong> 也都指向它们。</p>
<p>根据业务需求，可以做更深的伪装定制，通过以下测试：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">tagName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">nodeName</span> === <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">version</span> === <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentNode</span> === <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">parentElement</span> === <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHtmlElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHtmlElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">tagName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">nodeName</span> === <span class="string">&quot;BODY&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">constructor</span> === <span class="title class_">HTMLBodyElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLBodyElement</span> === <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">tagName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">nodeName</span> === <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="property">constructor</span> === <span class="title class_">HTMLHeadElement</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLHeadElement</span> === <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>注意 <strong>document.documentElement.parentElement</strong> ，如果等于 null，可能对一些视觉框架、组件库等需要用 parentElement 向上递归搜索的功能不友好。可根据需要是否开启以上伪装能力。</p>
<h3 id="4-2-存量-DOM"><a href="#4-2-存量-DOM" class="headerlink" title="4.2 存量 DOM"></a>4.2 存量 DOM</h3><p>存量 DOM 是指那些在子应用的 HTML entry 中已有的 DOM 结构，简单的如#app，也可能有更复杂的结构。</p>
<p>通常需要把它们同步到上述固定 DOM 的 body 中，也有些方案把 head 中的 meta 都同步了过来。</p>
<p>一旦需要拷贝，需要考虑如下问题：</p>
<ul>
<li>非法元素、样式的过滤；</li>
<li>元素在沙箱环境的适配</li>
</ul>
<h3 id="4-3-新增-DOM"><a href="#4-3-新增-DOM" class="headerlink" title="4.3 新增 DOM"></a>4.3 新增 DOM</h3><p>新增 DOM 有多种创建方式：</p>
<ul>
<li>document.createElement()；</li>
<li>dom.clone()；</li>
<li>dom.innerHTML&#x3D;</li>
</ul>
<p>通常来说只有第一种会被沙箱接管，使得新创建的 DOM 的 ownerDocument、baseURI 是符合沙箱环境的。</p>
<p>需要特别关注的是，新创建的 script 元素会被转换成一个无实际功能的&lt;pseudo-script&gt;元素。框架会在后台自行下载&#x2F;执行其代码，模拟了 script 的能力。</p>
<p>Custom Element默认是inline类型，除了在shadow DOM内部使用 <strong>:host{display:block}</strong> 外，只能在外部用选择器覆盖。未来如果Safari支持<a href="https://caniuse.com/custom-elementsv1" target="_blank">继承built-in元素</a>后可以解决。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>沙箱只能处理有限范围内的变量隔离，通常为 window 和 document；</li>
<li>以 eval function 的方式执行 JS 源码，全局变量引用应以 window 属性的方式使用；ESM 无法支持沙箱；</li>
<li>子应用的 DOM 结构可以被伪装，但仍然能轻易实现逃逸</li>
</ul>
<p><strong>沙箱的本质是为子应用打造一个微型的独立浏览器环境，受限于成本，无法做到尽善尽美，仍然需要子应用遵循一定的规范和约定</strong> 。而由于微前端的主、子应用在管理上的独立性，往往沙箱能力的升级会对子应用造成较大的影响。</p>
<h2 id="六、未来发展"><a href="#六、未来发展" class="headerlink" title="六、未来发展"></a>六、未来发展</h2><p>业界对沙箱的实现均强依赖 Proxy 技术，区别仅在于对副作用的拦截能力多少。随着业务复杂度的提升，以及一些存量旧业务在遵循冲突约定的改造成本上的考虑，逐渐意识到 Proxy 的能力仍然有限，想实现健壮性更强的沙箱环境，开发成本高且性能不稳定。</p>
<p>业界已经有一些方案开始逐渐回归 iframe。iframe 天生具有强隔离性，不必对全局变量一一关注即可达到期望的隔离性能。不过这种一刀切的做法在实际的业务中仍然受到挑战，比如对主动逃逸变量的支持，比如对 DOM 的操作等等，仍然需要一定的机制将 iframe 和主页面整合到一起。这一步，仍然离不开 Proxy 的支持。</p>
<p>ECMA 已经有一个新的提案，叫做<a href="https://github.com/tc39/proposal-shadowrealm" target="_blank">ShadowRealm</a>，位于 Stage3，对于创建独立的 JS 执行环境是一个比较理想的方案。不过微前端离不开视图，如何共享视图对象以及控制共享的粒度，就不是 ShadowRealm 的范围了。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/20/2022-04-20-keep-efficient-when-dont-known-what-doing/" rel="prev" title="《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效">
                  <i class="fa fa-angle-left"></i> 《咨询的奥秘》 第三章 在不知道自己在做什么时保持高效
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/01/10/2024-01-10-find-allan-poe/" rel="next" title="认识推理小说的奠基者——读《爱伦·坡短篇小说集》">
                  认识推理小说的奠基者——读《爱伦·坡短篇小说集》 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yanni4night</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/yanni4night" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"yanni4night","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
